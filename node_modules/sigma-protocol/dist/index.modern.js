import{Signature as t,Hash as s,Script as i,Transaction as r,BSM as n,BigNumber as e,Utils as o}from"@bsv/sdk";function a(){return a=Object.assign?Object.assign.bind():function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var r in i)({}).hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t},a.apply(null,arguments)}const{magicHash:h}=n,{toHex:u}=o,c="5349474d41";var g;!function(t){t.BSM="BSM"}(g||(g={}));class l{constructor(r,n=0,e=0,o=0){this._inputHash=null,this._dataHash=null,this._transaction=void 0,this._sigmaInstance=void 0,this._refVin=void 0,this._targetVout=void 0,this._sig=void 0,this.setHashes=()=>{this._inputHash=this.getInputHash(),this._dataHash=this.getDataHash()},this.setTargetVout=t=>{this._targetVout=t},this.setSigmaInstance=t=>{this._sigmaInstance=t},this.verify=()=>{if(!this.sig)throw new Error("No signature data provided");const s=this.getMessageHash();if(!s)throw new Error("No tx data provided");const i=t.fromCompact(this.sig.signature,"base64");return-1!==f(i,s,this.sig.address)},this.getInputHash=()=>this._getInputHashByVin(-1===this._refVin?this._targetVout:this._refVin),this._getInputHashByVin=t=>{const i=this._transaction.inputs[t];if(null!=i&&i.sourceTXID){const t=Buffer.alloc(36),r=Buffer.from(i.sourceTXID,"hex");return t.set(r,0),t.writeUInt32LE(i.sourceOutputIndex,32),s.sha256(Array.from(t))}return s.sha256(Array.from(new Uint8Array(32)))},this.getDataHash=()=>{var t;if(!this._transaction)throw new Error("No transaction provided");const r=null==(t=this._transaction)?void 0:t.outputs[this._targetVout].lockingScript,n=(null==r?void 0:r.toASM().split(" "))||[];let e=0;for(let t=0;t<n.length;t++)if(n[t].toUpperCase()===c.toUpperCase()){if(e===this._sigmaInstance){const r=n.slice(0,t-1),e=i.fromASM(r.join(" "));return s.sha256(e.toBinary())}e++}const o=i.fromASM(n.join(" "));return s.sha256(o.toBinary())},this._transaction=r,this._targetVout=n,this._refVin=o,this._sigmaInstance=e,this._sig=this.sig,this.setHashes()}getMessageHash(){if(!this._inputHash||!this._dataHash)throw new Error("Input hash and data hash must be set");const t=this._inputHash,i=this._dataHash,r=new Uint8Array(t.length+i.length);return r.set(t,0),r.set(i,t.length),s.sha256(Array.from(r))}get transaction(){return this._transaction}_sign(t,s,n){var e,o,h;const u=-1===this._refVin?this._targetVout:this._refVin;if(void 0===n)throw new Error("Failed recovery missing");const l=`${c} ${Buffer.from(g.BSM,"utf-8").toString("hex")} ${Buffer.from(s,"utf-8").toString("hex")} ${t.toCompact(n,!0,"hex")} ${Buffer.from(u.toString(),"utf-8").toString("hex")}`,f=i.fromASM(l);this._sig={algorithm:g.BSM,address:s,signature:t.toCompact(n,!0,"base64"),vin:u,targetVout:this._targetVout};let p=null==(e=this.targetTxOut)?void 0:e.lockingScript.toASM();const d=(null==(o=p)?void 0:o.split(" ").includes("OP_RETURN"))?"7c":"OP_RETURN";let _="";if(this.sig&&this._sigmaInstance===this.getSigInstanceCount()){var v;const t=(null==(v=p)?void 0:v.split(" "))||[],s=this.getSigInstancePosition(),i=l.split(" ");-1!==s&&(p=t.splice(s,5,...i).join(""))}_=`${p} ${d} ${l}`;const m=i.fromASM(_),S=new r(this._transaction.version,this._transaction.inputs.map(t=>a({},t)),this._transaction.outputs.map(t=>a({},t))),y={satoshis:null==(h=this.targetTxOut)?void 0:h.satoshis,lockingScript:m};return S.outputs[this._targetVout]=y,this._transaction=S,a({sigmaScript:f,signedTx:S},this._sig)}sign(t){const s=this.getMessageHash(),i=n.sign(s,t,"raw"),r=t.toAddress(),o=new e(h(s)),a=i.CalculateRecoveryFactor(t.toPublicKey(),o);return this._sign(i,r,a)}async remoteSign(s,i){const r=i?{[i.key]:i.value}:{},n=`${s}/sign${"query"===(null==i?void 0:i.type)?`?${null==i?void 0:i.key}=${null==i?void 0:i.value}`:""}`,e={message:u(this.getMessageHash()),encoding:"hex"};try{const s=await fetch(n,{method:"POST",headers:a({},r,{"Content-Type":"application/json",Accept:"application/json"}),body:JSON.stringify(e)});if(!s.ok){const t=await s.text();throw console.error("Response Error:",t),new Error(`HTTP Error: ${s.status}`)}const i=await s.json(),{address:o,sig:h,recovery:u}=i,c=t.fromCompact(h,"base64");return this._sign(c,o,u)}catch(t){throw console.error("Fetch Error:",t),t}}get targetTxOut(){return this._transaction.outputs[this._targetVout]||null}get sig(){const t=this._transaction.outputs[this._targetVout],s=null==t?void 0:t.lockingScript,i=(null==s?void 0:s.toASM().split(" "))||[],r=[];for(let t=0;t<i.length;t++)if(i[t].toUpperCase()===c.toUpperCase()){const s={algorithm:Buffer.from(i[t+1],"hex").toString("utf-8"),address:Buffer.from(i[t+2],"hex").toString("utf-8"),signature:Buffer.from(i[t+3],"hex").toString("base64"),vin:Number.parseInt(Buffer.from(i[t+4],"hex").toString("utf-8"))};r.push(s),t+=4}return 0===r.length?this._sig:r[this._sigmaInstance]}getSigInstanceCount(){var t;const s=null==(t=this.targetTxOut)?void 0:t.lockingScript.toASM();return((null==s?void 0:s.split(" "))||[]).filter(t=>t.toUpperCase()===c.toUpperCase()).length}getSigInstancePosition(){var t;const s=null==(t=this.targetTxOut)?void 0:t.lockingScript.toASM();return((null==s?void 0:s.split(" "))||[]).findIndex(t=>t.toUpperCase()===c.toUpperCase())}}const f=(t,s,i)=>{for(let r=0;r<4;r++)try{const o=t.RecoverPublicKey(r,new e(h(s)));if(n.verify(s,t,o)&&o.toAddress()===i)return r}catch(t){}return-1};export{g as Algorithm,l as Sigma,c as sigmaHex};
//# sourceMappingURL=index.modern.js.map
