{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import {\n\tBSM,\n\tHash,\n\ttype PrivateKey,\n\tScript,\n\tSignature,\n\tTransaction,\n\ttype TransactionOutput,\n\tBigNumber,\n} from \"@bsv/sdk\";\nimport { Utils } from \"@bsv/sdk\";\nconst { magicHash } = BSM;\nconst {\n\ttoHex,\n  toArray\n} = Utils\n\nexport type AuthToken = {\n\ttype: \"header\" | \"query\";\n\tvalue: string;\n\tkey: string;\n};\n\nexport type RemoteSigningResponse = {\n\taddress: string;\n\tsig: string;\n\tmessage: string;\n\tts: number;\n  recovery: number;\n};\n\nexport const sigmaHex = \"5349474d41\";\nexport enum Algorithm {\n\tBSM = \"BSM\",\n}\n\nexport type Sig = {\n\taddress: string;\n\tsignature: string;\n\talgorithm: Algorithm;\n\tvin: number;\n\ttargetVout: number;\n};\n\nexport interface SignResponse extends Sig {\n\tsigmaScript: Script;\n\tsignedTx: Transaction;\n}\n\nexport class Sigma {\n\tprivate _inputHash: number[] | null = null;\n\tprivate _dataHash: number[] | null = null;\n\tprivate _transaction: Transaction;\n\tprivate _sigmaInstance: number;\n\tprivate _refVin: number;\n\tprivate _targetVout: number;\n\tprivate _sig: Sig | null;\n\n\tconstructor(\n\t\ttransaction: Transaction,\n\t\ttargetVout = 0,\n\t\tsigmaInstance = 0,\n\t\trefVin = 0,\n\t) {\n\t\tthis._transaction = transaction;\n\t\tthis._targetVout = targetVout;\n\t\tthis._refVin = refVin;\n\t\tthis._sigmaInstance = sigmaInstance;\n\t\tthis._sig = this.sig;\n\t\tthis.setHashes();\n\t}\n\n\tsetHashes = () => {\n\t\tthis._inputHash = this.getInputHash();\n\t\tthis._dataHash = this.getDataHash();\n\t};\n\n\tsetTargetVout = (targetVout: number) => {\n\t\tthis._targetVout = targetVout;\n\t};\n\n\tsetSigmaInstance = (sigmaInstance: number) => {\n\t\tthis._sigmaInstance = sigmaInstance;\n\t};\n\n\tgetMessageHash(): number[] {\n\t\tif (!this._inputHash || !this._dataHash) {\n\t\t\tthrow new Error(\"Input hash and data hash must be set\");\n\t\t}\n\n\t\tconst inputBytes = this._inputHash;\n\t\tconst dataBytes = this._dataHash;\n\t\tconst combinedHashes = new Uint8Array(inputBytes.length + dataBytes.length);\n\t\tcombinedHashes.set(inputBytes, 0);\n\t\tcombinedHashes.set(dataBytes, inputBytes.length);\n\t\t// console.log(\"combinedHashes\", Buffer.from(combinedHashes).toString('hex'))\n\t\treturn Hash.sha256(Array.from(combinedHashes));\n\t}\n\n\tget transaction(): Transaction {\n\t\treturn this._transaction;\n\t}\n\n\t_sign(signature: Signature, address: string, recovery: number) {\n\t\tconst vin = this._refVin === -1 ? this._targetVout : this._refVin;\n    if (recovery === undefined) {\n      throw new Error(\"Failed recovery missing\")\n    }\n\t\tconst signedAsm = `${sigmaHex} ${Buffer.from(\n\t\t\tAlgorithm.BSM,\n\t\t\t\"utf-8\",\n\t\t).toString(\"hex\")} ${Buffer.from(address, \"utf-8\").toString(\n\t\t\t\"hex\",\n\t\t)} ${signature.toCompact(recovery, true, \"hex\")} ${Buffer.from(\n\t\t\tvin.toString(),\n\t\t\t\"utf-8\",\n\t\t).toString(\"hex\")}`;\n\n\t\tconst sigmaScript = Script.fromASM(signedAsm);\n\n\t\tthis._sig = {\n\t\t\talgorithm: Algorithm.BSM,\n\t\t\taddress: address,\n\t\t\tsignature: signature.toCompact(recovery, true, \"base64\") as string,\n\t\t\tvin,\n\t\t\ttargetVout: this._targetVout,\n\t\t};\n\n\t\tlet existingAsm = this.targetTxOut?.lockingScript.toASM();\n\t\tconst containsOpReturn = existingAsm?.split(\" \").includes(\"OP_RETURN\");\n\t\tconst separator = containsOpReturn ? \"7c\" : \"OP_RETURN\";\n\n\t\tlet newScriptAsm = \"\";\n\n\t\tconst existingSig = this.sig;\n\n\t\t// sigmaIndex is 0 based while count is 1 based\n\t\tif (existingSig && this._sigmaInstance === this.getSigInstanceCount()) {\n\t\t\t// Replace the existing signature\n\t\t\tconst scriptChunks = existingAsm?.split(\" \") || [];\n\t\t\tconst sigIndex = this.getSigInstancePosition();\n\n\t\t\tconst newSignedAsmChunks = signedAsm.split(\" \");\n\t\t\tif (sigIndex !== -1) {\n\t\t\t\texistingAsm = scriptChunks\n\t\t\t\t\t.splice(sigIndex, 5, ...newSignedAsmChunks)\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\t\t}\n\t\t// Append the new signature\n\t\tnewScriptAsm = `${existingAsm} ${separator} ${signedAsm}`;\n\n\t\tconst newScript = Script.fromASM(newScriptAsm);\n\t\tconst signedTx = new Transaction(\n\t\t\tthis._transaction.version,\n\t\t\tthis._transaction.inputs.map(i => ({ ...i })),\n\t\t\tthis._transaction.outputs.map(o => ({ ...o }))\n\t\t);\n\t\tconst signedTxOut = {\n\t\t\tsatoshis: this.targetTxOut?.satoshis,\n\t\t\tlockingScript: newScript,\n\t\t} as TransactionOutput;\n\t\tsignedTx.outputs[this._targetVout] = signedTxOut;\n\n\t\t// update the object state\n\t\tthis._transaction = signedTx;\n\n\t\treturn {\n\t\t\tsigmaScript,\n\t\t\tsignedTx,\n\t\t\t...this._sig,\n\t\t};\n\t}\n\t// Sign with Sigma protocol\n\t// privateKey: a @bsv/ts-sdk PrivateKey\n\t// inputs: either an array of TxIn from @bsv/ts-sdk or an array o string txids\n\t//    must be in the same order they are added to the transaction\n\t//    adding input txids to the signature scheme eliminates replay attacks\n\t// dataHash: a sha256 hash of the data to be signed\n\t//     it should include all the data in the output script prior to the \"SIGMA\" protocol instance\n\t//     excluding the \"|\" protocol separator and \"SIGMA\" prefix itself\n\tsign(privateKey: PrivateKey): SignResponse {\n\t\tconst message = this.getMessageHash();\n\t\tconst signature = BSM.sign(message, privateKey, 'raw') as Signature;\n\t\tconst address = privateKey.toAddress();\n\n    const h = new BigNumber(magicHash(message))\n    const recovery = signature.CalculateRecoveryFactor(privateKey.toPublicKey(), h)\n\t\treturn this._sign(signature, address, recovery);\n\t}\n\tasync remoteSign(\n\t\tkeyHost: string,\n\t\tauthToken?: AuthToken,\n\t): Promise<SignResponse> {\n\t\tconst headers = authToken\n\t\t\t? {\n\t\t\t\t[authToken.key]: authToken.value,\n\t\t\t}\n\t\t\t: {};\n\n\t\tconst url = `${keyHost}/sign${authToken?.type === \"query\"\n\t\t\t\t? `?${authToken?.key}=${authToken?.value}`\n\t\t\t\t: \"\"\n\t\t\t}`;\n\n\t\tconst requestBody = {\n\t\t\tmessage: toHex(this.getMessageHash()),\n\t\t\tencoding: \"hex\",\n\t\t};\n\n\t\ttry {\n\t\t\tconst response = await fetch(url, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t...headers,\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify(requestBody),\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconst errorResponse = await response.text();\n\t\t\t\tconsole.error(\"Response Error:\", errorResponse);\n\t\t\t\tthrow new Error(`HTTP Error: ${response.status}`);\n\t\t\t}\n\n\t\t\tconst responseData = await response.json() as RemoteSigningResponse\n\t\t\tconst { address, message, sig, recovery } = responseData;\n\t\t\tconst signature = Signature.fromCompact(sig, \"base64\");\n\n\t\t\treturn this._sign(signature, address, recovery);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Fetch Error:\", error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tverify = () => {\n\t\tif (!this.sig) {\n\t\t\tthrow new Error(\"No signature data provided\");\n\t\t}\n\t\tconst msgHash = this.getMessageHash()\n\t\tif (!msgHash) {\n\t\t\tthrow new Error(\"No tx data provided\");\n\t\t}\n\n\t\tconst signature = Signature.fromCompact(this.sig.signature, \"base64\");\n    const recovery = deduceRecovery(signature, msgHash, this.sig.address)\n\t\treturn recovery !== -1\n\t};\n\n\tgetInputHash = (): number[] => {\n\t\t// if vin is -1, we're signing the corresponding input\n\t\t// so we use this._targetVout as the vin\n\t\t// this allows for better compatibility with partially signed transactions\n\t\t// where the anchor input index is not known\n\t\tconst vin = this._refVin === -1 ? this._targetVout : this._refVin;\n\t\treturn this._getInputHashByVin(vin);\n\t};\n\n\tprivate _getInputHashByVin = (vin: number): number[] => {\n\t\tconst txIn = this._transaction.inputs[vin];\n\t\tif (txIn?.sourceTXID) {\n\t\t\tconst outpointBytes = Buffer.alloc(36)\n\t\t\tconst txidBuf = Buffer.from(txIn.sourceTXID, 'hex')\n\t\t\toutpointBytes.set(txidBuf, 0)\n\t\t\toutpointBytes.writeUInt32LE(txIn.sourceOutputIndex, 32)\n\t\t\treturn Hash.sha256(Array.from(outpointBytes));\n\t\t}\n\t\t// using dummy hash\n\t\treturn Hash.sha256(Array.from(new Uint8Array(32)));\n\t};\n\n\t// gets the Hash.sha256 for a given sigma instance within an output script\n\t// an example of 2 instances would be a user signature followed by a platform signature\n\tgetDataHash = (): number[] => {\n\t\tif (!this._transaction) {\n\t\t\tthrow new Error(\"No transaction provided\");\n\t\t}\n\t\tconst outputScript =\n\t\t\tthis._transaction?.outputs[this._targetVout].lockingScript;\n\n\t\tconst scriptChunks = outputScript?.toASM().split(\" \") || [];\n\n\t\t// loop over the script chunks and set the endIndex when the nTh instance is found\n\t\tlet occurances = 0;\n\t\tfor (let i = 0; i < scriptChunks.length; i++) {\n\t\t\tif (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\n\t\t\t\tif (occurances === this._sigmaInstance) {\n\t\t\t\t\t// the -1 is to account for either the OP_RETURN\n\t\t\t\t\t// or \"|\" separator which is not signed\n\t\t\t\t\tconst dataChunks = scriptChunks.slice(0, i - 1);\n\t\t\t\t\tconst dataScript = Script.fromASM(dataChunks.join(\" \"));\n\t\t\t\t\treturn Hash.sha256(dataScript.toBinary());\n\t\t\t\t}\n\t\t\t\toccurances++;\n\t\t\t}\n\t\t}\n\n\t\t// If no endIndex found, return the hash for the entire script\n\t\tconst dataScript = Script.fromASM(scriptChunks.join(\" \"));\n\t\treturn Hash.sha256(dataScript.toBinary());\n\t};\n\n\tget targetTxOut(): TransactionOutput | null {\n\t\treturn this._transaction.outputs[this._targetVout] || null;\n\t}\n\n\t// get the signature from the selected sigma instance\n\tget sig(): Sig | null {\n\t\tconst output = this._transaction.outputs[this._targetVout];\n\t\tconst outputScript = output?.lockingScript;\n\n\t\tconst scriptChunks = outputScript?.toASM().split(\" \") || [];\n\t\tconst instances: Sig[] = [];\n\n\t\tfor (let i = 0; i < scriptChunks.length; i++) {\n\t\t\tif (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\n\t\t\t\tconst sig = {\n\t\t\t\t\talgorithm: Buffer.from(scriptChunks[i + 1], \"hex\").toString(\"utf-8\"),\n\t\t\t\t\taddress: Buffer.from(scriptChunks[i + 2], \"hex\").toString(\"utf-8\"),\n\t\t\t\t\tsignature: Buffer.from(scriptChunks[i + 3], \"hex\").toString(\"base64\"),\n\t\t\t\t\tvin: Number.parseInt(\n\t\t\t\t\t\tBuffer.from(scriptChunks[i + 4], \"hex\").toString(\"utf-8\"),\n\t\t\t\t\t),\n\t\t\t\t} as Sig;\n\n\t\t\t\tinstances.push(sig);\n\n\t\t\t\t// fast forward to the next possible instance position\n\t\t\t\t// 3 fields + 1 extra for the \"|\" separator\n\t\t\t\ti += 4;\n\t\t\t}\n\t\t}\n\t\treturn instances.length === 0 ? this._sig : instances[this._sigmaInstance];\n\t}\n\n\tgetSigInstanceCount(): number {\n\t\tconst existingAsm = this.targetTxOut?.lockingScript.toASM();\n\t\tconst scriptChunks: string[] = existingAsm?.split(\" \") || [];\n\t\treturn scriptChunks.filter(\n\t\t\t(chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase(),\n\t\t).length;\n\t}\n\n\tgetSigInstancePosition(): number {\n\t\tconst existingAsm = this.targetTxOut?.lockingScript.toASM();\n\t\tconst scriptChunks: string[] = existingAsm?.split(\" \") || [];\n\t\treturn scriptChunks.findIndex(\n\t\t\t(chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase(),\n\t\t);\n\t}\n}\n\n\n// Deduce the recovery factor for a given signature, returns -1 if recovery is not possible\nconst deduceRecovery = (signature: Signature, message: number[], address: string): number => {\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, new BigNumber(magicHash(message)))\n      const sigFitsPubkey = BSM.verify(message, signature, publicKey);\n      if (sigFitsPubkey && publicKey.toAddress() === address) {\n        return recovery\n      }\n    } catch (e) {\n      // try next recovery\n    }\n  }\n  return -1\n}"],"names":["magicHash","BSM","toHex","Utils","sigmaHex","Algorithm","Sigma","constructor","transaction","targetVout","sigmaInstance","refVin","_inputHash","_dataHash","_transaction","_sigmaInstance","_refVin","this","_targetVout","_sig","setHashes","getInputHash","getDataHash","setTargetVout","setSigmaInstance","verify","sig","Error","msgHash","getMessageHash","signature","Signature","fromCompact","deduceRecovery","address","_getInputHashByVin","vin","txIn","inputs","sourceTXID","outpointBytes","Buffer","alloc","txidBuf","from","set","writeUInt32LE","sourceOutputIndex","Hash","sha256","Array","Uint8Array","_this$_transaction","outputScript","outputs","lockingScript","scriptChunks","toASM","split","occurances","i","length","toUpperCase","dataChunks","slice","dataScript","Script","fromASM","join","toBinary","inputBytes","dataBytes","combinedHashes","_sign","recovery","_this$targetTxOut","_existingAsm","_this$targetTxOut2","undefined","signedAsm","toString","toCompact","sigmaScript","algorithm","existingAsm","targetTxOut","separator","includes","newScriptAsm","getSigInstanceCount","_existingAsm2","sigIndex","getSigInstancePosition","newSignedAsmChunks","splice","newScript","signedTx","Transaction","version","map","_extends","o","signedTxOut","satoshis","sign","privateKey","message","toAddress","h","BigNumber","CalculateRecoveryFactor","toPublicKey","remoteSign","keyHost","authToken","headers","key","value","url","type","requestBody","encoding","response","fetch","method","Accept","body","JSON","stringify","ok","errorResponse","text","console","error","status","responseData","json","output","instances","Number","parseInt","push","_this$targetTxOut3","filter","chunk","_this$targetTxOut4","findIndex","publicKey","RecoverPublicKey","e"],"mappings":"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"}