{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["import {\n\tBSM,\n\tHash,\n\ttype PrivateKey,\n\tScript,\n\tSignature,\n\tTransaction,\n\ttype TransactionOutput,\n\tBigNumber,\n} from \"@bsv/sdk\";\nimport { Utils } from \"@bsv/sdk\";\nconst { magicHash } = BSM;\nconst {\n\ttoHex,\n  toArray\n} = Utils\n\nexport type AuthToken = {\n\ttype: \"header\" | \"query\";\n\tvalue: string;\n\tkey: string;\n};\n\nexport type RemoteSigningResponse = {\n\taddress: string;\n\tsig: string;\n\tmessage: string;\n\tts: number;\n  recovery: number;\n};\n\nexport const sigmaHex = \"5349474d41\";\nexport enum Algorithm {\n\tBSM = \"BSM\",\n}\n\nexport type Sig = {\n\taddress: string;\n\tsignature: string;\n\talgorithm: Algorithm;\n\tvin: number;\n\ttargetVout: number;\n};\n\nexport interface SignResponse extends Sig {\n\tsigmaScript: Script;\n\tsignedTx: Transaction;\n}\n\nexport class Sigma {\n\tprivate _inputHash: number[] | null = null;\n\tprivate _dataHash: number[] | null = null;\n\tprivate _transaction: Transaction;\n\tprivate _sigmaInstance: number;\n\tprivate _refVin: number;\n\tprivate _targetVout: number;\n\tprivate _sig: Sig | null;\n\n\tconstructor(\n\t\ttransaction: Transaction,\n\t\ttargetVout = 0,\n\t\tsigmaInstance = 0,\n\t\trefVin = 0,\n\t) {\n\t\tthis._transaction = transaction;\n\t\tthis._targetVout = targetVout;\n\t\tthis._refVin = refVin;\n\t\tthis._sigmaInstance = sigmaInstance;\n\t\tthis._sig = this.sig;\n\t\tthis.setHashes();\n\t}\n\n\tsetHashes = () => {\n\t\tthis._inputHash = this.getInputHash();\n\t\tthis._dataHash = this.getDataHash();\n\t};\n\n\tsetTargetVout = (targetVout: number) => {\n\t\tthis._targetVout = targetVout;\n\t};\n\n\tsetSigmaInstance = (sigmaInstance: number) => {\n\t\tthis._sigmaInstance = sigmaInstance;\n\t};\n\n\tgetMessageHash(): number[] {\n\t\tif (!this._inputHash || !this._dataHash) {\n\t\t\tthrow new Error(\"Input hash and data hash must be set\");\n\t\t}\n\n\t\tconst inputBytes = this._inputHash;\n\t\tconst dataBytes = this._dataHash;\n\t\tconst combinedHashes = new Uint8Array(inputBytes.length + dataBytes.length);\n\t\tcombinedHashes.set(inputBytes, 0);\n\t\tcombinedHashes.set(dataBytes, inputBytes.length);\n\t\t// console.log(\"combinedHashes\", Buffer.from(combinedHashes).toString('hex'))\n\t\treturn Hash.sha256(Array.from(combinedHashes));\n\t}\n\n\tget transaction(): Transaction {\n\t\treturn this._transaction;\n\t}\n\n\t_sign(signature: Signature, address: string, recovery: number) {\n\t\tconst vin = this._refVin === -1 ? this._targetVout : this._refVin;\n    if (recovery === undefined) {\n      throw new Error(\"Failed recovery missing\")\n    }\n\t\tconst signedAsm = `${sigmaHex} ${Buffer.from(\n\t\t\tAlgorithm.BSM,\n\t\t\t\"utf-8\",\n\t\t).toString(\"hex\")} ${Buffer.from(address, \"utf-8\").toString(\n\t\t\t\"hex\",\n\t\t)} ${signature.toCompact(recovery, true, \"hex\")} ${Buffer.from(\n\t\t\tvin.toString(),\n\t\t\t\"utf-8\",\n\t\t).toString(\"hex\")}`;\n\n\t\tconst sigmaScript = Script.fromASM(signedAsm);\n\n\t\tthis._sig = {\n\t\t\talgorithm: Algorithm.BSM,\n\t\t\taddress: address,\n\t\t\tsignature: signature.toCompact(recovery, true, \"base64\") as string,\n\t\t\tvin,\n\t\t\ttargetVout: this._targetVout,\n\t\t};\n\n\t\tlet existingAsm = this.targetTxOut?.lockingScript.toASM();\n\t\tconst containsOpReturn = existingAsm?.split(\" \").includes(\"OP_RETURN\");\n\t\tconst separator = containsOpReturn ? \"7c\" : \"OP_RETURN\";\n\n\t\tlet newScriptAsm = \"\";\n\n\t\tconst existingSig = this.sig;\n\n\t\t// sigmaIndex is 0 based while count is 1 based\n\t\tif (existingSig && this._sigmaInstance === this.getSigInstanceCount()) {\n\t\t\t// Replace the existing signature\n\t\t\tconst scriptChunks = existingAsm?.split(\" \") || [];\n\t\t\tconst sigIndex = this.getSigInstancePosition();\n\n\t\t\tconst newSignedAsmChunks = signedAsm.split(\" \");\n\t\t\tif (sigIndex !== -1) {\n\t\t\t\texistingAsm = scriptChunks\n\t\t\t\t\t.splice(sigIndex, 5, ...newSignedAsmChunks)\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\t\t}\n\t\t// Append the new signature\n\t\tnewScriptAsm = `${existingAsm} ${separator} ${signedAsm}`;\n\n\t\tconst newScript = Script.fromASM(newScriptAsm);\n\t\tconst signedTx = new Transaction(\n\t\t\tthis._transaction.version,\n\t\t\tthis._transaction.inputs.map(i => ({ ...i })),\n\t\t\tthis._transaction.outputs.map(o => ({ ...o }))\n\t\t);\n\t\tconst signedTxOut = {\n\t\t\tsatoshis: this.targetTxOut?.satoshis,\n\t\t\tlockingScript: newScript,\n\t\t} as TransactionOutput;\n\t\tsignedTx.outputs[this._targetVout] = signedTxOut;\n\n\t\t// update the object state\n\t\tthis._transaction = signedTx;\n\n\t\treturn {\n\t\t\tsigmaScript,\n\t\t\tsignedTx,\n\t\t\t...this._sig,\n\t\t};\n\t}\n\t// Sign with Sigma protocol\n\t// privateKey: a @bsv/ts-sdk PrivateKey\n\t// inputs: either an array of TxIn from @bsv/ts-sdk or an array o string txids\n\t//    must be in the same order they are added to the transaction\n\t//    adding input txids to the signature scheme eliminates replay attacks\n\t// dataHash: a sha256 hash of the data to be signed\n\t//     it should include all the data in the output script prior to the \"SIGMA\" protocol instance\n\t//     excluding the \"|\" protocol separator and \"SIGMA\" prefix itself\n\tsign(privateKey: PrivateKey): SignResponse {\n\t\tconst message = this.getMessageHash();\n\t\tconst signature = BSM.sign(message, privateKey, 'raw') as Signature;\n\t\tconst address = privateKey.toAddress();\n\n    const h = new BigNumber(magicHash(message))\n    const recovery = signature.CalculateRecoveryFactor(privateKey.toPublicKey(), h)\n\t\treturn this._sign(signature, address, recovery);\n\t}\n\tasync remoteSign(\n\t\tkeyHost: string,\n\t\tauthToken?: AuthToken,\n\t): Promise<SignResponse> {\n\t\tconst headers = authToken\n\t\t\t? {\n\t\t\t\t[authToken.key]: authToken.value,\n\t\t\t}\n\t\t\t: {};\n\n\t\tconst url = `${keyHost}/sign${authToken?.type === \"query\"\n\t\t\t\t? `?${authToken?.key}=${authToken?.value}`\n\t\t\t\t: \"\"\n\t\t\t}`;\n\n\t\tconst requestBody = {\n\t\t\tmessage: toHex(this.getMessageHash()),\n\t\t\tencoding: \"hex\",\n\t\t};\n\n\t\ttry {\n\t\t\tconst response = await fetch(url, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t...headers,\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify(requestBody),\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconst errorResponse = await response.text();\n\t\t\t\tconsole.error(\"Response Error:\", errorResponse);\n\t\t\t\tthrow new Error(`HTTP Error: ${response.status}`);\n\t\t\t}\n\n\t\t\tconst responseData = await response.json() as RemoteSigningResponse\n\t\t\tconst { address, message, sig, recovery } = responseData;\n\t\t\tconst signature = Signature.fromCompact(sig, \"base64\");\n\n\t\t\treturn this._sign(signature, address, recovery);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Fetch Error:\", error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tverify = () => {\n\t\tif (!this.sig) {\n\t\t\tthrow new Error(\"No signature data provided\");\n\t\t}\n\t\tconst msgHash = this.getMessageHash()\n\t\tif (!msgHash) {\n\t\t\tthrow new Error(\"No tx data provided\");\n\t\t}\n\n\t\tconst signature = Signature.fromCompact(this.sig.signature, \"base64\");\n    const recovery = deduceRecovery(signature, msgHash, this.sig.address)\n\t\treturn recovery !== -1\n\t};\n\n\tgetInputHash = (): number[] => {\n\t\t// if vin is -1, we're signing the corresponding input\n\t\t// so we use this._targetVout as the vin\n\t\t// this allows for better compatibility with partially signed transactions\n\t\t// where the anchor input index is not known\n\t\tconst vin = this._refVin === -1 ? this._targetVout : this._refVin;\n\t\treturn this._getInputHashByVin(vin);\n\t};\n\n\tprivate _getInputHashByVin = (vin: number): number[] => {\n\t\tconst txIn = this._transaction.inputs[vin];\n\t\tif (txIn?.sourceTXID) {\n\t\t\tconst outpointBytes = Buffer.alloc(36)\n\t\t\tconst txidBuf = Buffer.from(txIn.sourceTXID, 'hex')\n\t\t\toutpointBytes.set(txidBuf, 0)\n\t\t\toutpointBytes.writeUInt32LE(txIn.sourceOutputIndex, 32)\n\t\t\treturn Hash.sha256(Array.from(outpointBytes));\n\t\t}\n\t\t// using dummy hash\n\t\treturn Hash.sha256(Array.from(new Uint8Array(32)));\n\t};\n\n\t// gets the Hash.sha256 for a given sigma instance within an output script\n\t// an example of 2 instances would be a user signature followed by a platform signature\n\tgetDataHash = (): number[] => {\n\t\tif (!this._transaction) {\n\t\t\tthrow new Error(\"No transaction provided\");\n\t\t}\n\t\tconst outputScript =\n\t\t\tthis._transaction?.outputs[this._targetVout].lockingScript;\n\n\t\tconst scriptChunks = outputScript?.toASM().split(\" \") || [];\n\n\t\t// loop over the script chunks and set the endIndex when the nTh instance is found\n\t\tlet occurances = 0;\n\t\tfor (let i = 0; i < scriptChunks.length; i++) {\n\t\t\tif (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\n\t\t\t\tif (occurances === this._sigmaInstance) {\n\t\t\t\t\t// the -1 is to account for either the OP_RETURN\n\t\t\t\t\t// or \"|\" separator which is not signed\n\t\t\t\t\tconst dataChunks = scriptChunks.slice(0, i - 1);\n\t\t\t\t\tconst dataScript = Script.fromASM(dataChunks.join(\" \"));\n\t\t\t\t\treturn Hash.sha256(dataScript.toBinary());\n\t\t\t\t}\n\t\t\t\toccurances++;\n\t\t\t}\n\t\t}\n\n\t\t// If no endIndex found, return the hash for the entire script\n\t\tconst dataScript = Script.fromASM(scriptChunks.join(\" \"));\n\t\treturn Hash.sha256(dataScript.toBinary());\n\t};\n\n\tget targetTxOut(): TransactionOutput | null {\n\t\treturn this._transaction.outputs[this._targetVout] || null;\n\t}\n\n\t// get the signature from the selected sigma instance\n\tget sig(): Sig | null {\n\t\tconst output = this._transaction.outputs[this._targetVout];\n\t\tconst outputScript = output?.lockingScript;\n\n\t\tconst scriptChunks = outputScript?.toASM().split(\" \") || [];\n\t\tconst instances: Sig[] = [];\n\n\t\tfor (let i = 0; i < scriptChunks.length; i++) {\n\t\t\tif (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\n\t\t\t\tconst sig = {\n\t\t\t\t\talgorithm: Buffer.from(scriptChunks[i + 1], \"hex\").toString(\"utf-8\"),\n\t\t\t\t\taddress: Buffer.from(scriptChunks[i + 2], \"hex\").toString(\"utf-8\"),\n\t\t\t\t\tsignature: Buffer.from(scriptChunks[i + 3], \"hex\").toString(\"base64\"),\n\t\t\t\t\tvin: Number.parseInt(\n\t\t\t\t\t\tBuffer.from(scriptChunks[i + 4], \"hex\").toString(\"utf-8\"),\n\t\t\t\t\t),\n\t\t\t\t} as Sig;\n\n\t\t\t\tinstances.push(sig);\n\n\t\t\t\t// fast forward to the next possible instance position\n\t\t\t\t// 3 fields + 1 extra for the \"|\" separator\n\t\t\t\ti += 4;\n\t\t\t}\n\t\t}\n\t\treturn instances.length === 0 ? this._sig : instances[this._sigmaInstance];\n\t}\n\n\tgetSigInstanceCount(): number {\n\t\tconst existingAsm = this.targetTxOut?.lockingScript.toASM();\n\t\tconst scriptChunks: string[] = existingAsm?.split(\" \") || [];\n\t\treturn scriptChunks.filter(\n\t\t\t(chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase(),\n\t\t).length;\n\t}\n\n\tgetSigInstancePosition(): number {\n\t\tconst existingAsm = this.targetTxOut?.lockingScript.toASM();\n\t\tconst scriptChunks: string[] = existingAsm?.split(\" \") || [];\n\t\treturn scriptChunks.findIndex(\n\t\t\t(chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase(),\n\t\t);\n\t}\n}\n\n\n// Deduce the recovery factor for a given signature, returns -1 if recovery is not possible\nconst deduceRecovery = (signature: Signature, message: number[], address: string): number => {\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, new BigNumber(magicHash(message)))\n      const sigFitsPubkey = BSM.verify(message, signature, publicKey);\n      if (sigFitsPubkey && publicKey.toAddress() === address) {\n        return recovery\n      }\n    } catch (e) {\n      // try next recovery\n    }\n  }\n  return -1\n}"],"names":["magicHash","BSM","toHex","Utils","sigmaHex","Algorithm","Sigma","transaction","targetVout","sigmaInstance","refVin","_this","this","_inputHash","_dataHash","_transaction","_sigmaInstance","_refVin","_targetVout","_sig","setHashes","getInputHash","getDataHash","setTargetVout","setSigmaInstance","verify","sig","Error","msgHash","getMessageHash","signature","Signature","fromCompact","deduceRecovery","address","_getInputHashByVin","vin","txIn","inputs","sourceTXID","outpointBytes","Buffer","alloc","txidBuf","from","set","writeUInt32LE","sourceOutputIndex","Hash","sha256","Array","Uint8Array","_this$_transaction","outputScript","outputs","lockingScript","scriptChunks","toASM","split","occurances","i","length","toUpperCase","dataChunks","slice","dataScript","Script","fromASM","join","toBinary","_proto","prototype","inputBytes","dataBytes","combinedHashes","_sign","recovery","_this$targetTxOut","_existingAsm","_this$targetTxOut2","undefined","signedAsm","toString","toCompact","sigmaScript","algorithm","existingAsm","targetTxOut","separator","includes","getSigInstanceCount","_existingAsm2","sigIndex","getSigInstancePosition","newSignedAsmChunks","splice","apply","concat","newScript","signedTx","Transaction","version","map","_extends","o","signedTxOut","satoshis","sign","privateKey","message","toAddress","h","BigNumber","CalculateRecoveryFactor","toPublicKey","remoteSign","keyHost","authToken","_ref","_this2","headers","key","value","url","type","requestBody","encoding","Promise","resolve","fetch","method","Accept","body","JSON","stringify","then","response","_temp2","_result","_exit","json","responseData","_temp","ok","text","errorResponse","console","error","status","_catch","e","reject","_this$targetTxOut3","filter","chunk","_this$targetTxOut4","findIndex","get","output","instances","Number","parseInt","push","publicKey","RecoverPublicKey"],"mappings":"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"}