{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["/**\n * Determines if all the passed args are strings\n * @param args The arguments to check\n */\nexport function isString(...args: unknown[]) {\n  return args.every(arg => typeof arg === 'string');\n}\n\n/**\n * Determines if all the passed args are numbers\n * @param args The arguments to check\n */\nexport function isNumber(...args: unknown[]) {\n  return args.every(arg => typeof arg === 'number');\n}\n\n/**\n * Determines if all the passed args are bigints\n * @param args The arguments to check\n */\nexport function isBigInt(...args: unknown[]) {\n  return args.every(arg => typeof arg === 'bigint');\n}\n","import { isBigInt, isNumber, isString } from \"./utils.js\";\n\n// Conditional return type\ntype ReturnType = \"string\" | \"bigint\" | \"number\";\ntype RT<T extends ReturnType> = T extends \"string\"\n\t? string\n\t: T extends \"bigint\"\n\t\t? bigint\n\t\t: number;\n\nexport const ReturnTypes = {\n\tString: \"string\" as const,\n\tBigInt: \"bigint\" as const,\n\tNumber: \"number\" as const,\n};\n\n/**\n * Convert token-sat to token\n * @param tokenSat Amount of token-sat to convert. Must be a whole number\n * @param decimals Number of decimal places for the token\n * @param returnString Optionally return the value as a string\n */\nexport function toToken<T extends ReturnType = \"number\">(\n\ttokenSat: number | string | bigint,\n\tdecimals: number,\n\treturnType?: T,\n): RT<T> {\n\tif (!isString(tokenSat) && !isNumber(tokenSat)) {\n\t\tthrow new TypeError(\n\t\t\t`toToken must be called on a number or string, got ${typeof tokenSat}`,\n\t\t);\n\t}\n\tif (!Number.isInteger(Number(tokenSat))) {\n\t\tthrow new TypeError(\n\t\t\t\"toToken must be called on a whole number or string format whole number\",\n\t\t);\n\t}\n\tif (!Number.isInteger(decimals) || decimals < 0) {\n\t\tthrow new TypeError(\"decimals must be a non-negative integer\");\n\t}\n\n\tlet tokenSatBig = 0n;\n\tconst isNegative =\n\t\ttypeof tokenSat === \"string\" ? tokenSat.startsWith(\"-\") : tokenSat < 0;\n\n\tswitch (typeof tokenSat) {\n\t\tcase \"bigint\":\n\t\t\ttokenSatBig = tokenSat;\n\t\t\tbreak;\n\t\tcase \"string\":\n\t\t\ttokenSatBig = BigInt(tokenSat.replace(\"-\", \"\").split(\".\")[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttokenSatBig = BigInt(Math.abs(Math.round(tokenSat)));\n\t}\n\n\tconst sign = isNegative ? -1n : 1n;\n\tconst intPart = tokenSatBig / 10n ** BigInt(decimals);\n\tconst decPart = tokenSatBig % 10n ** BigInt(decimals);\n\n\tswitch (returnType) {\n\t\tcase \"bigint\":\n      if (decPart > 0) {\n        throw new Error(\"toToken: Cannot return a bigint with decimal part\");\n      }\n\t\t\treturn (intPart * sign) as RT<T>;\n\t\tcase \"string\":\n\t\t\treturn `${isNegative && (intPart > 0 || decPart > 0) ? \"-\" : \"\"}${intPart}.${decPart.toString().padStart(decimals, \"0\")}` as RT<T>;\n\t\tdefault:\n\t\t\treturn Number(\n\t\t\t\t`${isNegative && (intPart > 0 || decPart > 0) ? \"-\" : \"\"}${intPart}.${decPart.toString().padStart(decimals, \"0\")}`,\n\t\t\t) as RT<T>;\n\t}\n}\n\n/**\n * Convert token to token-sat\n * @param token Amount of token to convert\n * @param decimals Number of decimal places for the token\n * @param returnString Optionally return the value as a string\n */\nexport function toTokenSat<T extends ReturnType = \"number\">(\n\ttoken: number | string | bigint,\n\tdecimals: number,\n\treturnType?: T,\n): RT<T> {\n\tif (!isString(token) && !isNumber(token) && !isBigInt(token)) {\n\t\tthrow new TypeError(\n\t\t\t`toTokenSat must be called on a number, string or bigint, got ${typeof token}`,\n\t\t);\n\t}\n\n\tif (!Number.isInteger(decimals) || decimals < 0) {\n\t\tthrow new TypeError(\"decimals must be a non-negative integer\");\n\t}\n\n\tlet result = \"\";\n\tconst isNegative =\n\t\ttypeof token === \"string\" ? token.startsWith(\"-\") && token !== \"-0\": token < 0;\n\n\tswitch (typeof token) {\n\t\tcase \"bigint\":\n\t\t\tresult = (token * 10n ** BigInt(decimals)).toString();\n\t\t\tbreak;\n\t\tcase \"string\": {\n\t\t\tconst absToken = token.replace(\"-\", \"\");\n\t\t\tconst [intStr, decStr] = absToken.split(\".\");\n\t\t\tresult = intStr + (decStr || \"\").padEnd(decimals, \"0\");\n\t\t\tif (isNegative && (intStr !== \"0\" || decStr !== \"0\")) result = `-${result}`;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t// result = Math.round(token * (10 ** decimals)).toString();\n\t\t\tresult = (\n\t\t\t\tMath.round(Math.abs(token) * 10 ** decimals) * (isNegative ? -1 : 1)\n\t\t\t).toString();\n\t}\n\n\tswitch (returnType) {\n\t\tcase \"bigint\":\n\t\t\treturn BigInt(result) as RT<T>;\n\t\tcase \"string\":\n\t\t\treturn result as RT<T>;\n\t\tdefault: {\n\t\t\tlet resultNum: number;\n\t\t\ttry {\n\t\t\t\tresultNum = Number(result);\n\t\t\t} catch (e) {\n\t\t\t\tthrow new Error(`Invalid number: ${result}`);\n\t\t\t}\n\n\t\t\tif (!Number.isSafeInteger(Math.round(resultNum))) {\n\t\t\t\tthrow new Error(\"Integer overflow. Try returning a string instead.\");\n\t\t\t}\n\t\t\treturn resultNum as RT<T>;\n\t\t}\n\t}\n}\n\n/**\n * Convert Bitcoin to Satoshis\n * @param token Amount of token to convert\n * @param returnString Optionally return the value as a string\n */\nexport function toSatoshi<T extends ReturnType = \"number\">(\n\ttoken: number | string | bigint,\n\treturnType?: T,\n): RT<T> {\n\treturn toTokenSat(token, 8, returnType);\n}\n\n/**\n * Convert Satoshis to Bitcoin\n * @param tokenSat Amount of token-sat to convert\n * @param returnString Optionally return the value as a string\n */\nexport function toBitcoin<T extends ReturnType = \"number\">(\n\ttokenSat: number | string | bigint,\n\treturnType?: T,\n): RT<T> {\n\treturn toToken(tokenSat, 8, returnType);\n}\n"],"names":["isString","args","every","arg","isNumber","ReturnTypes","String","BigInt","Number","toToken","tokenSat","decimals","returnType","TypeError","isInteger","tokenSatBig","isNegative","startsWith","replace","split","Math","abs","round","sign","intPart","decPart","Error","toString","padStart","toTokenSat","token","isBigInt","result","absToken","intStr","decStr","padEnd","resultNum","e","isSafeInteger","toSatoshi","toBitcoin"],"mappings":"AAIgB,SAAAA,KAAYC,GAC1B,OAAOA,EAAKC,MAAMC,GAAsB,iBAARA,EAClC,CAMgB,SAAAC,KAAYH,GAC1B,OAAOA,EAAKC,MAAMC,GAAsB,iBAARA,EAClC,CCJa,MAAAE,EAAc,CAC1BC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,mBASOC,EACfC,EACAC,EACAC,GAEA,IAAKZ,EAASU,KAAcN,EAASM,GACpC,MAAM,IAAIG,UACT,4DAA4DH,GAG9D,IAAKF,OAAOM,UAAUN,OAAOE,IAC5B,UAAUG,UACT,0EAGF,IAAKL,OAAOM,UAAUH,IAAaA,EAAW,EAC7C,MAAU,IAAAE,UAAU,2CAGrB,IAAIE,EAAc,GAClB,MAAMC,EACe,iBAAbN,EAAwBA,EAASO,WAAW,KAAOP,EAAW,EAEtE,cAAeA,GACd,IAAK,SACJK,EAAcL,EACd,MACD,IAAK,SACJK,EAAcR,OAAOG,EAASQ,QAAQ,IAAK,IAAIC,MAAM,KAAK,IAC1D,MACD,QACCJ,EAAcR,OAAOa,KAAKC,IAAID,KAAKE,MAAMZ,KAG3C,MAAMa,EAAOP,GAAc,GAAK,GAC1BQ,EAAUT,EAAc,KAAOR,OAAOI,GACtCc,EAAUV,EAAc,KAAOR,OAAOI,GAE5C,OAAQC,GACP,IAAK,SACD,GAAIa,EAAU,EACZ,MAAU,IAAAC,MAAM,qDAErB,OAAQF,EAAUD,EACnB,IAAK,SACJ,MAAO,GAAGP,IAAeQ,EAAU,GAAKC,EAAU,GAAK,IAAM,KAAKD,KAAWC,EAAQE,WAAWC,SAASjB,EAAU,OACpH,QACC,OAAOH,OACN,GAAGQ,IAAeQ,EAAU,GAAKC,EAAU,GAAK,IAAM,KAAKD,KAAWC,EAAQE,WAAWC,SAASjB,EAAU,QAGhH,UAQgBkB,EACfC,EACAnB,EACAC,GAEA,IAAKZ,EAAS8B,KAAW1B,EAAS0B,KDlEnB,YAAY7B,GAC1B,OAAOA,EAAKC,MAAMC,GAAsB,iBAARA,EAClC,CCgE8C4B,CAASD,GACrD,MAAU,IAAAjB,UACT,uEAAuEiB,GAIzE,IAAKtB,OAAOM,UAAUH,IAAaA,EAAW,EAC7C,MAAU,IAAAE,UAAU,2CAGrB,IAAImB,EAAS,GACb,MAAMhB,EACY,iBAAVc,EAAqBA,EAAMb,WAAW,MAAkB,OAAVa,EAAgBA,EAAQ,EAE9E,cAAeA,GACd,IAAK,SACJE,GAAUF,EAAQ,KAAOvB,OAAOI,IAAWgB,WAC3C,MACD,IAAK,SAAU,CACd,MAAMM,EAAWH,EAAMZ,QAAQ,IAAK,KAC7BgB,EAAQC,GAAUF,EAASd,MAAM,KACxCa,EAASE,GAAUC,GAAU,IAAIC,OAAOzB,EAAU,MAC9CK,GAA0B,MAAXkB,GAA6B,MAAXC,IAAiBH,EAAS,IAAIA,KACnE,KACD,CACA,QAECA,GACCZ,KAAKE,MAAMF,KAAKC,IAAIS,GAAS,IAAMnB,IAAaK,GAAc,EAAI,IACjEW,WAGJ,OAAQf,GACP,IAAK,SACJ,OAAOL,OAAOyB,GACf,IAAK,SACJ,OAAOA,EACR,QAAS,CACR,IAAIK,EACJ,IACCA,EAAY7B,OAAOwB,EACpB,CAAE,MAAOM,GACR,MAAU,IAAAZ,MAAM,mBAAmBM,IACpC,CAEA,IAAKxB,OAAO+B,cAAcnB,KAAKE,MAAMe,IACpC,MAAM,IAAIX,MAAM,qDAEjB,OAAOW,CACR,EAEF,UAOgBG,EACfV,EACAlB,GAEA,OAAOiB,EAAWC,EAAO,EAAGlB,EAC7B,UAOgB6B,EACf/B,EACAE,GAEA,OAAOH,EAAQC,EAAU,EAAGE,EAC7B"}