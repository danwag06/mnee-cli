import{P2PKH as t,LockingScript as o,Script as e,Utils as n,fromUtxo as s,SatoshisPerKilobyte as r,Transaction as i,OP as a,BigNumber as c,UnlockingScript as u,TransactionSignature as d,NodejsHttpClient as f}from"@bsv/sdk";import{toToken as l,toTokenSat as p,ReturnTypes as h}from"satoshi-token";import{Sigma as g}from"sigma-protocol";import{imageMeta as w}from"image-meta";const m=t=>Buffer.from(t).toString("hex"),y="1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5",k=10,b="https://ordinals.gorillapool.io/api";class I extends t{lock(o,e,n){const s=(new t).lock(o);return B(s,e,n)}}const B=(t,e,n,s=!1)=>{let r="";if(void 0!==(null==e?void 0:e.dataB64)&&void 0!==(null==e?void 0:e.contentType)){const t=m("ord"),o=Buffer.from(e.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=m(e.contentType);if(!n)throw new Error("Invalid media type");r=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`}let i=`${r?`${r} ${s?"OP_CODESEPARATOR ":""}`:""}${t.toASM()}`;if(n&&(!n.app||!n.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=n&&n.app&&null!=n&&n.type){i=`${i?`${i} `:""}OP_RETURN ${m(y)} ${m("SET")}`;for(const[t,o]of Object.entries(n))"cmd"!==t&&(i=`${i} ${m(t)} ${m(o)}`)}return o.fromASM(i)};function S(){return S=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var e=arguments[o];for(var n in e)({}).hasOwnProperty.call(e,n)&&(t[n]=e[n])}return t},S.apply(null,arguments)}var x,v,E,O;!function(t){t.SmallestFirst="smallest",t.LargestFirst="largest",t.RetainOrder="retain",t.Random="random"}(x||(x={})),function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(v||(v={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(E||(E={})),function(t){t.All="all",t.Needed="needed"}(O||(O={}));const A=2n**64n-1n,{fromBase58Check:P}=n,$=(t,o)=>s(S({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o),T=async(o,e="base64")=>{const n=`${b}/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:n});const s=await fetch(n);if(!s.ok)throw new Error("Error fetching pay utxos");let r=await s.json();r=r.filter(t=>1!==t.satoshis&&!C(t));const i=P(o),a=(new t).lock(i.data);return r=r.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===e||"base64"===e?Buffer.from(a.toBinary()).toString(e):a.toASM()})),r},N=async(t,o,n=10,s=0,r="base64")=>{let i=`${b}/txos/address/${t}/unspent?limit=${n}&offset=${s}&`;o&&(i+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:o}}})).toString("base64")}`);const a=await fetch(i);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let c=await a.json();c=c.filter(t=>{var o;return 1===t.satoshis&&!(null!=(o=t.data)&&o.list)});const u=c.map(t=>`${t.txid}_${t.vout}`),d=await fetch(`${b}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...u])});if(!d.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return c=(await d.json()||[]).map(t=>{let n=t.script;"hex"===r?n=Buffer.from(n,"base64").toString("hex"):"asm"===r&&(n=e.fromHex(Buffer.from(n,"base64").toString("hex")).toASM());const s={origin:t.origin.outpoint,script:n,vout:t.vout,txid:t.txid,satoshis:1};return o&&(s.collectionId=o),s}),c},q=async(t,o,e,n=10,s=0)=>{const r=`${b}/bsv20/${e}/${t===v.BSV20?"tick":"id"}/${o}?bsv20=true&listing=false&limit=${n}&offset=${s}`,i=await fetch(r);if(!i.ok)throw new Error(`Error fetching ${t} utxos`);let a=await i.json();return a=a.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:o,satoshis:1})),a},C=t=>!!t.lock,_=(t,o,e,n={})=>{const{inputStrategy:s=x.RetainOrder,outputStrategy:r=x.RetainOrder}=n,i=[...t].sort((t,o)=>{if(s===x.RetainOrder)return 0;const e=BigInt(t.amt),n=BigInt(o.amt);switch(s){case x.SmallestFirst:return Number(e-n);case x.LargestFirst:return Number(n-e);case x.Random:return Math.random()-.5;default:return 0}});let a=0;const c=[];for(const t of i)if(c.push(t),a+=l(t.amt,e),a>=o&&o>0)break;return r!==x.RetainOrder&&c.sort((t,o)=>{const e=BigInt(t.amt),n=BigInt(o.amt);switch(r){case x.SmallestFirst:return Number(e-n);case x.LargestFirst:return Number(n-e);case x.Random:return Math.random()-.5;default:return 0}}),{selectedUtxos:c,totalSelected:a,isEnough:a>=o}},F=async(t,o)=>{const e=null==o?void 0:o.idKey,n=null==o?void 0:o.keyHost;if(e){const o=new g(t),{signedTx:n}=o.sign(e);return n}if(n){const e=null==o?void 0:o.authToken,s=new g(t);try{const{signedTx:t}=await s.remoteSign(n,e);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${n} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},D=t=>{if(!t)return;const o={app:t.app,type:t.type};for(const[e,n]of Object.entries(t))void 0!==n&&(o[e]="string"==typeof n?n:Array.isArray(n)||"object"==typeof n?JSON.stringify(n):String(n));return o},L=async o=>{const{utxos:s,destinations:a,paymentPk:c,satsPerKb:u=k,metaData:d,signer:f,additionalPayments:l=[]}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const p=new r(u);let h,g=new i;for(const t of a){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(d)for(const t of Object.keys(d))void 0===d[t]&&delete d[t];g.addOutput({satoshis:1,lockingScript:(new I).lock(t.address,t.inscription,D(d))})}for(const o of l)g.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const w=o.changeAddress||(null==c?void 0:c.toAddress());if(!w)throw new Error("Either changeAddress or paymentPk is required");const m=(new t).lock(w);g.addOutput({lockingScript:m,change:!0});let y=0n;const b=g.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);if(f){const o=s.pop(),r=o.pk||c;if(!r)throw new Error("Private key is required to sign the transaction");g.addInput($(o,(new t).unlock(r,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))))),y+=BigInt(o.satoshis),g=await F(g,f)}let B=0;for(const o of s){const s=o.pk||c;if(!s)throw new Error("Private key is required to sign the transaction");if(y>=b+BigInt(B))break;const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));g.addInput(r),y+=BigInt(o.satoshis),B=await p.computeFee(g)}if(y<b+BigInt(B))throw new Error(`Not enough funds to create ordinals. Total sats in: ${y}, Total sats out: ${b}, Fee: ${B}`);await g.fee(p),await g.sign();const S=g.outputs.findIndex(t=>t.change);if(-1!==S){const t=g.outputs[S];h={satoshis:t.satoshis,txid:g.id("hex"),vout:S,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return h&&(h.satoshis=g.outputs[g.outputs.length-1].satoshis,h.txid=g.id("hex")),{tx:g,spentOutpoints:s.map(t=>`${t.txid}_${t.vout}`),payChange:h}},R=async o=>{o.satsPerKb||(o.satsPerKb=k),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const{ordPk:s,paymentPk:a}=o,c=new r(o.satsPerKb);let u=new i;const d=[];for(const t of o.ordinals){const o=t.pk||s;if(!o)throw new Error("Private key is required to sign the ordinal");if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const r=$(t,(new I).unlock(o,"all",!0,t.satoshis,e.fromBinary(n.toArray(t.script,"base64"))));d.push(`${t.txid}_${t.vout}`),u.addInput(r)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const e of o.destinations){var f,l;let n;n=null!=(f=e.inscription)&&f.dataB64&&null!=(l=e.inscription)&&l.contentType?(new I).lock(e.address,e.inscription,D(o.metaData)):(new t).lock(e.address),u.addOutput({satoshis:1,lockingScript:n})}for(const e of o.additionalPayments)u.addOutput({satoshis:e.amount,lockingScript:(new t).lock(e.to)});let p;const h=o.changeAddress||(null==a?void 0:a.toAddress());if(!h)throw new Error("Either changeAddress or paymentPk is required");const g=(new t).lock(h);u.addOutput({lockingScript:g,change:!0});let w=0n;const m=u.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let y=0;for(const s of o.paymentUtxos){const o=s.pk||a;if(!o)throw new Error("Private key is required to sign the payment");const r=$(s,(new t).unlock(o,"all",!0,s.satoshis,e.fromBinary(n.toArray(s.script,"base64"))));if(d.push(`${s.txid}_${s.vout}`),u.addInput(r),w+=BigInt(s.satoshis),y=await c.computeFee(u),w>=m+BigInt(y))break}if(w<m)throw new Error("Not enough ordinals to send");o.signer&&(u=await F(u,o.signer)),await u.fee(c),await u.sign();const b=u.outputs.findIndex(t=>t.change);if(-1!==b){const t=u.outputs[b];p={satoshis:t.satoshis,txid:u.id("hex"),vout:b,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return p&&(p.satoshis=u.outputs[u.outputs.length-1].satoshis,p.txid=u.id("hex")),{tx:u,spentOutpoints:d,payChange:p}},U=async o=>{const{utxos:s,paymentPk:a,payments:c,satsPerKb:u=k,metaData:d}=o,f=new r(u),l=new i;for(const t of c){const o={satoshis:t.amount,lockingScript:(new I).lock(t.to,void 0,d)};l.addOutput(o)}let p=0n;const h=l.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let g,w=0;for(const o of s){const s=o.pk||a;if(!s)throw new Error("Private key is required to sign the utxos");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(l.addInput(r),p+=BigInt(o.satoshis),w=await f.computeFee(l),p>=h+w)break}if(p<h+w)throw new Error(`Not enough funds to send. Total sats in: ${p}, Total sats out: ${h}, Fee: ${w}`);if(p>h+w){const e=o.changeAddress||(null==a?void 0:a.toAddress());if(!e)throw new Error("Either changeAddress or paymentPk is required");const n=(new t).lock(e),s={lockingScript:n,change:!0};g={txid:"",vout:l.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},l.addOutput(s)}else p<h+w&&console.log("No change needed");await l.fee(f),await l.sign();const m=l.outputs.findIndex(t=>t.change);if(-1!==m){const t=l.outputs[m];g={satoshis:t.satoshis,txid:l.id("hex"),vout:m,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return g&&(g.satoshis=l.outputs[l.outputs.length-1].satoshis,g.txid=l.id("hex")),{tx:l,spentOutpoints:s.map(t=>`${t.txid}_${t.vout}`),payChange:g}},j=async o=>{const{protocol:s,tokenID:a,utxos:c,inputTokens:u,distributions:d,paymentPk:f,ordPk:l,satsPerKb:g=k,metaData:w,signer:m,decimals:y,additionalPayments:b=[],burn:x=!1,tokenInputMode:E=O.Needed,splitConfig:A={outputs:1,omitMetaData:!1}}=o;if(!u.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");let P=0n,T=0n,N=0n;const q=d.reduce((t,o)=>t+p(o.tokens,y,h.BigInt),0n),C=new r(g);let _,L=new i;if(E===O.All)_=u,T=u.reduce((t,o)=>t+BigInt(o.amt),0n);else{_=[];for(const t of u)if(_.push(t),T+=BigInt(t.amt),T>=q)break;if(T<q)throw new Error("Not enough tokens to satisfy the transfer amount")}for(const t of _){const o=t.pk||l;if(!o)throw new Error("Private key required for token input");const s=n.toArray(t.script,"base64"),r=e.fromBinary(s);L.addInput($(t,(new I).unlock(o,"all",!0,t.satoshis,r)))}if(w)for(const t of Object.keys(w))void 0===w[t]&&delete w[t];for(const t of d){const o=p(t.tokens,y,h.BigInt);console.log({distTokenSat:o});const e={p:"bsv-20",op:x?"burn":"transfer",amt:o.toString()};let n;if(s===v.BSV20)n=S({},e,{tick:a});else{if(s!==v.BSV21)throw new Error("Invalid protocol");n=S({},e,{id:a})}const r={dataB64:Buffer.from(JSON.stringify(n)).toString("base64"),contentType:"application/bsv-20"};let i="string"==typeof t.address?(new I).lock(t.address,r,t.omitMetaData?void 0:D(w)):B(t.address,r);L.addOutput({satoshis:1,lockingScript:i}),N+=o}if(P=T-N,P<0n)throw new Error("Not enough tokens to send");let R,U=[];if(P>0n){const t=o.tokenChangeAddress||(null==l?void 0:l.toAddress());if(!t)throw new Error("ordPk or changeAddress required for token change");U=M(L,P,s,a,t,w,A,y)}for(const o of b)L.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const j=o.changeAddress||(null==f?void 0:f.toAddress());if(!j)throw new Error("paymentPk or changeAddress required for payment change");const K=(new t).lock(j);L.addOutput({lockingScript:K,change:!0});let V=0n;const H=L.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let J=0;for(const o of c){const s=o.pk||f;if(!s)throw new Error("paymentPk required for payment utxo");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(L.addInput(r),V+=BigInt(o.satoshis),J=await C.computeFee(L),V>=H+BigInt(J))break}if(V<H+BigInt(J))throw new Error(`Not enough funds to transfer tokens. Total sats in: ${V}, Total sats out: ${H}, Fee: ${J}`);m&&(L=await F(L,m)),await L.fee(C),await L.sign();const X=L.id("hex");for(const t of U)t.txid=X;const W=L.outputs.findIndex(t=>t.change);if(-1!==W){const t=L.outputs[W];R={satoshis:t.satoshis,txid:X,vout:W,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return R&&(R.satoshis=L.outputs[L.outputs.length-1].satoshis,R.txid=L.id("hex")),{tx:L,spentOutpoints:L.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:R,tokenChange:U}},M=(t,o,e,n,s,r,i,a)=>{const c=[],u=void 0!==i.threshold?p(i.threshold,a,h.BigInt):void 0,d=i.outputs,f=o;let l;console.log({splitChangeAmt:f}),void 0!==u&&u>0n?(l=f/u,l=BigInt(Math.min(Number(l),d))):l=BigInt(d),l=BigInt(Math.max(Number(l),1));const g=f/l;let w=f%l;for(let o=0n;o<l;o++){let o=g;w>0n&&(o+=1n,w-=1n);const a={p:"bsv-20",op:"transfer",amt:o.toString()};let u;if(e===v.BSV20)u=S({},a,{tick:n});else{if(e!==v.BSV21)throw new Error("Invalid protocol");u=S({},a,{id:n})}const d=(new I).lock(s,{dataB64:Buffer.from(JSON.stringify(u)).toString("base64"),contentType:"application/bsv-20"},i.omitMetaData?void 0:D(r)),f=t.outputs.length;t.addOutput({lockingScript:d,satoshis:1}),c.push({id:n,satoshis:1,script:Buffer.from(d.toBinary()).toString("base64"),txid:"",vout:f,amt:o.toString()})}return c},K=(t,o)=>{try{if("collection"===t){const t=o;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(o=>"string"==typeof o&&"object"==typeof t.traits[o]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=o;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};class V{lock(o,s,r,i){const a=n.fromBase58Check(o).data,c=n.fromBase58Check(s).data;let u=new e;if(void 0!==(null==i?void 0:i.dataB64)&&void 0!==(null==i?void 0:i.contentType)){const t=m("ord"),o=Buffer.from(i.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=m(i.contentType);if(!n)throw new Error("Invalid media type");u=e.fromASM(`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`)}return u.writeScript(e.fromHex("2097dfd76851bf465e8f715593b217714858bbe9570ff3bd5e33840a34e20ff0262102ba79df5f8ae7604a9830f03c7933028186aede0675a16f025dc4f8be8eec0382201008ce7480da41702918d1ec8e6849ba32b4d65b1e40dc669c31a1e6306b266c0000")).writeBin(a).writeBin(V.buildOutput(r,(new t).lock(c).toBinary())).writeScript(e.fromHex("615179547a75537a537a537a0079537a75527a527a7575615579008763567901c161517957795779210ac407f0e4bd44bfc207355a778b046225a7068fc59ee7eda43ad905aadbffc800206c266b30e6a1319c66dc401e5bd6b432ba49688eecd118297041da8074ce081059795679615679aa0079610079517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01007e81517a75615779567956795679567961537956795479577995939521414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff00517951796151795179970079009f63007952799367007968517a75517a75517a7561527a75517a517951795296a0630079527994527a75517a6853798277527982775379012080517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01205279947f7754537993527993013051797e527e54797e58797e527e53797e52797e57797e0079517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a756100795779ac517a75517a75517a75517a75517a75517a75517a75517a75517a7561517a75517a756169587951797e58797eaa577961007982775179517958947f7551790128947f77517a75517a75618777777777777777777767557951876351795779a9876957795779ac777777777777777767006868"))}cancelListing(o,e="all",n=!1,s,r){const i=(new t).unlock(o,e,n,s,r);return{sign:async function(t,o){return(await i.sign(t,o)).writeOpCode(a.OP_1)},estimateLength:async function(){return 107}}}purchaseListing(t,o){const e={sign:async function(e,s){var r;if(e.outputs.length<2)throw new Error("Malformed transaction");const i=(new u).writeBin(V.buildOutput(e.outputs[0].satoshis||0,e.outputs[0].lockingScript.toBinary()));if(e.outputs.length>2){const t=new n.Writer;for(const o of e.outputs.slice(2))t.write(V.buildOutput(o.satoshis||0,o.lockingScript.toBinary()));i.writeBin(t.toArray())}else i.writeOpCode(a.OP_0);const c=e.inputs[s];let f=t;if(!f&&c.sourceTransaction)f=c.sourceTransaction.outputs[c.sourceOutputIndex].satoshis;else if(!t)throw new Error("sourceTransaction or sourceSatoshis is required");const l=c.sourceTXID||(null==(r=c.sourceTransaction)?void 0:r.id("hex"));let p=o;var h;p||(p=null==(h=c.sourceTransaction)?void 0:h.outputs[c.sourceOutputIndex].lockingScript);const g=d.format({sourceTXID:l,sourceOutputIndex:c.sourceOutputIndex,sourceSatoshis:f,transactionVersion:e.version,otherInputs:[],inputIndex:s,outputs:e.outputs,inputSequence:c.sequence,subscript:p,lockTime:e.lockTime,scope:d.SIGHASH_ALL|d.SIGHASH_ANYONECANPAY|d.SIGHASH_FORKID});return i.writeBin(g).writeOpCode(a.OP_0)},estimateLength:async function(t,o){return(await e.sign(t,o)).toBinary().length}};return e}static buildOutput(t,o){const e=new n.Writer;return e.writeUInt64LEBn(new c(t)),e.writeVarIntNum(o.length),e.write(o),e.toArray()}}const{toArray:H}=n,J=async o=>{const{utxos:s,listings:a,paymentPk:c,ordPk:u,satsPerKb:d=k,additionalPayments:f=[]}=o,l=new r(d),p=new i;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of a){p.addOutput({satoshis:1,lockingScript:(new V).lock(t.ordAddress,t.payAddress,t.price)});const o=H(t.listingUtxo.script,"base64"),n=e.fromBinary(o),s=t.listingUtxo.pk||u;if(!s)throw new Error("Private key is required to sign the ordinal");p.addInput($(t.listingUtxo,(new I).unlock(s,"all",!0,t.listingUtxo.satoshis,n)))}for(const o of f)p.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let h;const g=o.changeAddress||(null==c?void 0:c.toAddress());if(!g)throw new Error("changeAddress or private key is required");const w=(new t).lock(g);p.addOutput({lockingScript:w,change:!0});let m=0n;const y=p.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let b=0;for(const o of s){const s=o.pk||c;if(!s)throw new Error("Private key is required to sign the transaction");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(p.addInput(r),m+=BigInt(o.satoshis),b=await l.computeFee(p),m>=y+BigInt(b))break}if(m<y+BigInt(b))throw new Error(`Not enough funds to create ordinal listings. Total sats in: ${m}, Total sats out: ${y}, Fee: ${b}`);await p.fee(l),await p.sign();const B=p.outputs.findIndex(t=>t.change);if(-1!==B){const t=p.outputs[B];h={satoshis:t.satoshis,txid:p.id("hex"),vout:B,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return h&&(h.satoshis=p.outputs[p.outputs.length-1].satoshis,h.txid=p.id("hex")),{tx:p,spentOutpoints:p.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:h}},X=async o=>{const{utxos:s,protocol:a,tokenID:c,ordPk:u,paymentPk:d,additionalPayments:f=[],tokenChangeAddress:l,inputTokens:g,listings:w,decimals:m,satsPerKb:y=k}=o;if(w.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead."),!g.every(t=>t.id===c))throw new Error("Input tokens do not match the provided tokenID");let b=0n,B=0n,x=0n;if(!g.every(t=>t.id===c))throw new Error("Input tokens do not match the provided tokenID");const E=new r(y),O=new i;for(const t of w){const o=p(t.tokens,m,h.BigInt),e={p:"bsv-20",op:"transfer",amt:o.toString()};let n;if(a===v.BSV20)n=S({},e,{tick:c});else{if(a!==v.BSV21)throw new Error("Invalid protocol");n=S({},e,{id:c})}O.addOutput({satoshis:1,lockingScript:(new V).lock(t.ordAddress,t.payAddress,t.price,{dataB64:Buffer.from(JSON.stringify(n)).toString("base64"),contentType:"application/bsv-20"})}),x+=o}for(const t of g){const o=t.pk||u;if(!o)throw new Error("Private key is required to sign the ordinal");O.addInput($(t,(new I).unlock(o,"all",!0,t.satoshis,e.fromBinary(H(t.script,"base64"))))),B+=BigInt(t.amt)}let A,P;if(b=B-x,b<0n)throw new Error("Not enough tokens to send");if(b>0n){const t={p:"bsv-20",op:"transfer",amt:b.toString()};let o;if(a===v.BSV20)o=S({},t,{tick:c});else{if(a!==v.BSV21)throw new Error("Invalid protocol");o=S({},t,{id:c})}const e=(new I).lock(l,{dataB64:Buffer.from(JSON.stringify(o)).toString("base64"),contentType:"application/bsv-20"}),n=O.outputs.length;O.addOutput({lockingScript:e,satoshis:1}),A=[{id:c,satoshis:1,script:Buffer.from(e.toBinary()).toString("base64"),txid:"",vout:n,amt:b.toString()}]}for(const o of f)O.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const T=o.changeAddress||(null==d?void 0:d.toAddress());if(!T)throw new Error("Either changeAddress or paymentPk is required");const N=(new t).lock(T);O.addOutput({lockingScript:N,change:!0});let q=0n;const C=O.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let _=0;for(const o of s){const s=o.pk||d;if(!s)throw new Error("Private key is required to sign the payment");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(O.addInput(r),q+=BigInt(o.satoshis),_=await E.computeFee(O),q>=C+BigInt(_))break}if(q<C+BigInt(_))throw new Error(`Not enough funds to create token listings. Total sats in: ${q}, Total sats out: ${C}, Fee: ${_}`);await O.fee(E),await O.sign();const F=O.id("hex");A&&(A=A.map(t=>S({},t,{txid:F})));const D=O.outputs.findIndex(t=>t.change);if(-1!==D){const t=O.outputs[D];P={satoshis:t.satoshis,txid:F,vout:D,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return P&&(P.satoshis=O.outputs[O.outputs.length-1].satoshis,P.txid=O.id("hex")),{tx:O,spentOutpoints:O.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:P,tokenChange:A}},W=async o=>{const{utxos:s,listingUtxos:a,ordPk:c,paymentPk:u,additionalPayments:d=[],satsPerKb:f=k}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const l=new r(f),p=new i;for(const o of a){const s=o.pk||c;if(!s)throw new Error("Private key required for token input");p.addInput($(o,(new V).cancelListing(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))))),p.addOutput({satoshis:1,lockingScript:(new t).lock(s.toAddress().toString())})}for(const o of d)p.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let h;const g=o.changeAddress||(null==u?void 0:u.toAddress());if(!g)throw new Error("paymentPk or changeAddress required for payment change");const w=g,m=(new t).lock(w);p.addOutput({lockingScript:m,change:!0});let y=0n;const b=p.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let I=0;for(const o of s){const s=o.pk||u;if(!s)throw new Error("paymentPk required for payment utxo");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(p.addInput(r),y+=BigInt(o.satoshis),I=await l.computeFee(p),y>=b+BigInt(I))break}if(y<b+BigInt(I))throw new Error(`Not enough funds to cancel ordinal listings. Total sats in: ${y}, Total sats out: ${b}, Fee: ${I}`);await p.fee(l),await p.sign();const B=p.outputs.findIndex(t=>t.change);if(-1!==B){const t=p.outputs[B];h={satoshis:t.satoshis,txid:p.id("hex"),vout:B,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return h&&(h.satoshis=p.outputs[p.outputs.length-1].satoshis,h.txid=p.id("hex")),{tx:p,spentOutpoints:p.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:h}},G=async o=>{const{protocol:s,tokenID:a,paymentPk:c,ordPk:u,additionalPayments:d,listingUtxos:f,utxos:l,satsPerKb:p=k}=o;let h=0;if(f.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead."),!f.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");const g=new r(p),w=new i;for(const t of f){const o=t.pk||u;if(!o)throw new Error("Private key required for token input");w.addInput($(t,(new V).cancelListing(o,"all",!0,t.satoshis,e.fromBinary(n.toArray(t.script,"base64"))))),h+=Number.parseInt(t.amt)}const m={p:"bsv-20",op:"transfer",amt:h.toString()};let y;if(s===v.BSV20)y=S({},m,{tick:a});else{if(s!==v.BSV21)throw new Error("Invalid protocol");y=S({},m,{id:a})}const b=o.ordAddress||(null==u?void 0:u.toAddress());if(!b)throw new Error("ordAddress or ordPk required for token output");const B={address:b,inscription:{dataB64:Buffer.from(JSON.stringify(y)).toString("base64"),contentType:"application/bsv-20"}},x=(new I).lock(B.address,B.inscription);w.addOutput({satoshis:1,lockingScript:x});for(const o of d)w.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let E;const O=o.changeAddress||(null==c?void 0:c.toAddress());if(!O)throw new Error("paymentPk or changeAddress required for payment change");const A=(new t).lock(O);w.addOutput({lockingScript:A,change:!0});let P=0n;const T=w.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let N=0;for(const o of l){const s=o.pk||c;if(!s)throw new Error("paymentPk required for payment utxo");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(w.addInput(r),P+=BigInt(o.satoshis),N=await g.computeFee(w),P>=T+BigInt(N))break}if(P<T+BigInt(N))throw new Error(`Not enough funds to cancel token listings. Total sats in: ${P}, Total sats out: ${T}, Fee: ${N}`);await w.fee(g),await w.sign();const q=[{amt:h.toString(),script:Buffer.from(x.toHex(),"hex").toString("base64"),txid:w.id("hex"),vout:0,id:a,satoshis:1}],C=w.outputs.findIndex(t=>t.change);if(-1!==C){const t=w.outputs[C];E={satoshis:t.satoshis,txid:w.id("hex"),vout:C,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return E&&(E.satoshis=w.outputs[w.outputs.length-1].satoshis,E.txid=w.id("hex")),{tx:w,spentOutpoints:w.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:E,tokenChange:q}},Y=async(t,o)=>{throw new Error("Not implemented")},Q=async s=>{const{utxos:a,paymentPk:c,listing:u,ordAddress:d,additionalPayments:f=[],satsPerKb:l=k,royalties:p=[],metaData:h}=s,g=new r(l),w=new i;w.addInput($(u.listingUtxo,(new V).purchaseListing(1,e.fromBinary(n.toArray(u.listingUtxo.script,"base64"))))),w.addOutput({satoshis:1,lockingScript:(new I).lock(d,void 0,h)});const m=new n.Reader(n.toArray(u.payout,"base64")),y=m.readUInt64LEBn().toNumber(),b=m.readVarIntNum(),B=m.read(b),S=o.fromBinary(B);w.addOutput({satoshis:y,lockingScript:S});for(const o of f)w.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});for(const o of p){let s;const r=Math.floor(Number(o.percentage)*y);switch(o.type){case E.Paymail:s=await Y();break;case E.Script:s=e.fromBinary(n.toArray(o.destination,"base64"));break;case E.Address:s=(new t).lock(o.destination);break;default:throw new Error("Invalid royalty type")}if(!s)throw new Error("Invalid royalty destination");w.addOutput({satoshis:r,lockingScript:s})}let x;const v=s.changeAddress||(null==c?void 0:c.toAddress());if(!v)throw new Error("Either changeAddress or paymentPk is required");const O=(new t).lock(v);w.addOutput({lockingScript:O,change:!0});let A=0n;const P=w.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let T=0;for(const o of a){const s=o.pk||c;if(!s)throw new Error("Private key is required to sign the payment");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(w.addInput(r),A+=BigInt(o.satoshis),T=await g.computeFee(w),A>=P+BigInt(T))break}if(A<P+BigInt(T))throw new Error(`Not enough funds to purchase ordinal listing. Total sats in: ${A}, Total sats out: ${P}, Fee: ${T}`);await w.fee(g),await w.sign();const N=w.outputs.findIndex(t=>t.change);if(-1!==N){const t=w.outputs[N];x={satoshis:t.satoshis,txid:w.id("hex"),vout:N,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return x&&(x.satoshis=w.outputs[w.outputs.length-1].satoshis,x.txid=w.id("hex")),{tx:w,spentOutpoints:w.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:x}},z=async s=>{const{protocol:a,tokenID:c,utxos:u,paymentPk:d,listingUtxo:f,ordAddress:l,satsPerKb:p=k,additionalPayments:h=[],metaData:g}=s,w=new r(p),m=new i;m.addInput($(f,(new V).purchaseListing(1,e.fromBinary(n.toArray(f.script,"base64")))));const y={p:"bsv-20",op:"transfer",amt:f.amt};let b;if(a===v.BSV20)b=S({},y,{tick:c});else{if(a!==v.BSV21)throw new Error("Invalid protocol");b=S({},y,{id:c})}const B=Buffer.from(JSON.stringify(b)).toString("base64");if(m.addOutput({satoshis:1,lockingScript:(new I).lock(l,{dataB64:B,contentType:"application/bsv-20"},g)}),!f.payout)throw new Error("Listing UTXO does not have a payout script");const x=new n.Reader(n.toArray(f.payout,"base64")),E=x.readUInt64LEBn().toNumber(),O=x.readVarIntNum(),A=x.read(O),P=o.fromBinary(A);m.addOutput({satoshis:E,lockingScript:P});for(const o of h)m.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let T;const N=s.changeAddress||(null==d?void 0:d.toAddress());if(!N)throw new Error("Either changeAddress or paymentPk is required");const q=(new t).lock(N);m.addOutput({lockingScript:q,change:!0});let C=0n;const _=m.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let F=0;for(const o of u){const s=o.pk||d;if(!s)throw new Error("Private key is required to sign the payment");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(m.addInput(r),C+=BigInt(o.satoshis),F=await w.computeFee(m),C>=_+BigInt(F))break}if(C<_+BigInt(F))throw new Error(`Not enough funds to purchase token listing. Total sats in: ${C}, Total sats out: ${_}, Fee: ${F}`);await m.fee(w),await m.sign();const D=m.outputs.findIndex(t=>t.change);if(-1!==D){const t=m.outputs[D];T={satoshis:t.satoshis,txid:m.id("hex"),vout:D,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return T&&(T.satoshis=m.outputs[m.outputs.length-1].satoshis,T.txid=m.id("hex")),{tx:m,spentOutpoints:m.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:T}},{toArray:Z}=n,tt=new Error("Image must be a square image with dimensions <= 400x400"),ot=new Error("Image must be a square image"),et=new Error("Error processing image"),nt=new Error("Image dimensions are undefined"),st=async o=>{const{symbol:s,icon:a,decimals:c,utxos:u,initialDistribution:d,paymentPk:f,destinationAddress:l,satsPerKb:p=k,additionalPayments:h=[]}=o,g=new r(p),m=new i;let y;if("string"==typeof a)y=a;else{const t=await(async t=>{const{dataB64:o,contentType:e}=t;if("image/svg+xml"===e)return(t=>{const o=Buffer.from(t,"base64").toString("utf-8"),e=o.match(/<svg[^>]*\s+width="([^"]+)"/),n=o.match(/<svg[^>]*\s+height="([^"]+)"/);if(!e||!n)return nt;const s=Number.parseInt(e[1],10),r=Number.parseInt(n[1],10);return Number.isNaN(s)||Number.isNaN(r)?nt:s!==r?ot:s>400||r>400?tt:null})(o);if((n=e)!=n)return et;var n;try{const t=Uint8Array.from(Z(o,"base64")),e=w(t);return void 0===e.width||void 0===e.height?nt:e.width!==e.height?ot:e.width>400||e.height>400?tt:null}catch(t){return et}})(a);if(t)throw t;const o=(new I).lock(l,a);m.addOutput({satoshis:1,lockingScript:o}),y="_0"}if(!(t=>{if(!t.includes("_")||t.endsWith("_"))return!1;const o=Number.parseInt(t.split("_")[1]);return!(Number.isNaN(o)||!t.startsWith("_")&&64!==t.split("_")[0].length)})(y))throw new Error("Invalid icon format. Must be either outpoint (format: txid_vout) or relative output index of the icon (format _vout). examples: ecb483eda58f26da1b1f8f15b782b1186abdf9c6399a1c3e63e0d429d5092a41_0 or _1");const b={p:"bsv-20",op:"deploy+mint",sym:s,icon:y,amt:(c?BigInt(d.tokens)*10n**BigInt(c):BigInt(d.tokens)).toString()};c&&(b.dec=c.toString());const B=Buffer.from(JSON.stringify(b)).toString("base64"),S={satoshis:1,lockingScript:(new I).lock(l,{dataB64:B,contentType:"application/bsv-20"})};m.addOutput(S);for(const o of h){const e={satoshis:o.amount,lockingScript:(new t).lock(o.to)};m.addOutput(e)}let x=0n;const v=m.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let E,O=0;for(const o of u){const s=o.pk||f;if(!s)throw new Error("Private key is required to sign the payment");const r=$(o,(new t).unlock(s,"all",!0,o.satoshis,e.fromBinary(n.toArray(o.script,"base64"))));if(m.addInput(r),x+=BigInt(o.satoshis),O=await g.computeFee(m),x>=v+BigInt(O))break}if(x<v+BigInt(O))throw new Error(`Not enough funds to deploy token. Total sats in: ${x}, Total sats out: ${v}, Fee: ${O}`);const A=o.changeAddress||(null==f?void 0:f.toAddress());if(!A)throw new Error("Either changeAddress or paymentPk is required");const P=(new t).lock(A);m.addOutput({lockingScript:P,change:!0}),await m.fee(g),await m.sign();const T=m.outputs.findIndex(t=>t.change);if(-1!==T){const t=m.outputs[T];E={satoshis:t.satoshis,txid:m.id("hex"),vout:T,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return{tx:m,spentOutpoints:m.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:E}},rt=async t=>{const o=new i,s=[],{ordinals:r,metaData:a,ordPk:c}=t;for(const t of r){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const r=t.pk||c;if(!r)throw new Error("Private key is required to sign the ordinal");const i=$(t,(new I).unlock(r,"all",!0,t.satoshis,e.fromBinary(n.toArray(t.script,"base64"))));s.push(`${t.txid}_${t.vout}`),o.addInput(i)}if(a&&(!a.app||!a.type))throw new Error("MAP.app and MAP.type are required fields");let u="";if(null!=a&&a.app&&null!=a&&a.type){u=`OP_FALSE OP_RETURN ${m(y)} ${m("SET")}`;for(const[t,o]of Object.entries(a))"cmd"!==t&&(u=`${u} ${m(t)} ${m(o)}`)}return o.addOutput({satoshis:0,lockingScript:e.fromASM(u||"OP_FALSE OP_RETURN")}),await o.sign(),{tx:o,spentOutpoints:s}};class it{constructor(t){this.fetch=void 0,this.fetch=t}async request(t,o){const e={method:o.method,headers:o.headers,body:JSON.stringify(o.data)},n=await this.fetch.call(window,t,e),s=n.headers.get("Content-Type"),r=null!=s&&s.startsWith("application/json")?await n.json():await n.text();return{ok:n.ok,status:n.status,statusText:n.statusText,data:r}}}const at=()=>new ct;class ct{constructor(t=function(){const t={async request(...t){throw new Error("No method available to perform HTTP request")}};if("undefined"!=typeof window&&"function"==typeof window.fetch){const t=window.fetch;return window.fetch=async(...o)=>await t(...o),new it(window.fetch)}if("undefined"==typeof require)return t;try{const t=require("node:https");return new f(t)}catch(o){return t}}()){this.URL=void 0,this.httpClient=void 0,this.URL=`${b}/tx`,this.httpClient=t}async broadcast(t){const o={method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},data:{rawtx:n.toBase64(t.toBinary())}};try{var e,s;const t=await this.httpClient.request(this.URL,o);return t.ok?{status:"success",txid:t.data,message:"broadcast successful"}:{status:"error",code:null!=(e=t.status.toString())?e:"ERR_UNKNOWN",description:null!=(s=t.data.message)?s:"Unknown error"}}catch(t){return{status:"error",code:"500",description:t instanceof Error?t.message:"Internal Server Error"}}}}export{A as MAX_TOKEN_SUPPLY,ct as OneSatBroadcaster,V as OrdLock,I as OrdP2PKH,E as RoytaltyType,O as TokenInputMode,x as TokenSelectionStrategy,v as TokenType,B as applyInscription,rt as burnOrdinals,W as cancelOrdListings,G as cancelOrdTokenListings,J as createOrdListings,X as createOrdTokenListings,L as createOrdinals,st as deployBsv21Token,N as fetchNftUtxos,T as fetchPayUtxos,q as fetchTokenUtxos,at as oneSatBroadcaster,Q as purchaseOrdListing,z as purchaseOrdTokenListing,_ as selectTokenUtxos,R as sendOrdinals,U as sendUtxos,D as stringifyMetaData,j as transferOrdTokens,K as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
