"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sdk_1 = require("@bsv/sdk");
/**
 * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.
 *
 * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.
 */
class CosignTemplate {
    /**
     * Creates a P2PKH locking script for a given public key hash or address string
     *
     * @param {number[] | string} userPKHash or address - An array or address representing the public key hash of the owning user.
     * @param {PublicKey} approverPubKey - Public key of the approver.
     * @returns {LockingScript} - A P2PKH locking script.
     */
    lock(userPKHash, approverPubKey) {
        let pkhash = [];
        if (typeof userPKHash === "string") {
            const hash = sdk_1.Utils.fromBase58Check(userPKHash);
            if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f)
                throw new Error("only P2PKH is supported");
            pkhash = hash.data;
        }
        else {
            pkhash = userPKHash;
        }
        const lockingScript = new sdk_1.LockingScript();
        lockingScript
            .writeOpCode(sdk_1.OP.OP_DUP)
            .writeOpCode(sdk_1.OP.OP_HASH160)
            .writeBin(pkhash)
            .writeOpCode(sdk_1.OP.OP_EQUALVERIFY)
            .writeOpCode(sdk_1.OP.OP_CHECKSIGVERIFY)
            .writeBin(approverPubKey.encode(true))
            .writeOpCode(sdk_1.OP.OP_CHECKSIG);
        return lockingScript;
    }
    /**
     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.
     *
     * The returned object contains:
     * 1. `sign` - A function that, when invoked with a transaction and an input index,
     *    produces an unlocking script suitable for a P2PKH locked output.
     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
     *
     * @param {PrivateKey} userPrivateKey - The private key used for signing the transaction.
     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.
     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.
     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
     */
    userUnlock(userPrivateKey, signOutputs = "all", anyoneCanPay = false, sourceSatoshis, lockingScript) {
        return {
            sign: (tx, inputIndex) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                let signatureScope = sdk_1.TransactionSignature.SIGHASH_FORKID;
                if (signOutputs === "all") {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_ALL;
                }
                if (signOutputs === "none") {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_NONE;
                }
                if (signOutputs === "single") {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_SINGLE;
                }
                if (anyoneCanPay) {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_ANYONECANPAY;
                }
                const input = tx.inputs[inputIndex];
                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);
                const sourceTXID = input.sourceTXID
                    ? input.sourceTXID
                    : (_a = input.sourceTransaction) === null || _a === void 0 ? void 0 : _a.id("hex");
                if (!sourceTXID) {
                    throw new Error("The input sourceTXID or sourceTransaction is required for transaction signing.");
                }
                sourceSatoshis || (sourceSatoshis = (_b = input.sourceTransaction) === null || _b === void 0 ? void 0 : _b.outputs[input.sourceOutputIndex].satoshis);
                if (!sourceSatoshis) {
                    throw new Error("The sourceSatoshis or input sourceTransaction is required for transaction signing.");
                }
                lockingScript || (lockingScript = (_c = input.sourceTransaction) === null || _c === void 0 ? void 0 : _c.outputs[input.sourceOutputIndex].lockingScript);
                if (!lockingScript) {
                    throw new Error("The lockingScript or input sourceTransaction is required for transaction signing.");
                }
                const preimage = sdk_1.TransactionSignature.format({
                    sourceTXID,
                    sourceOutputIndex: input.sourceOutputIndex,
                    sourceSatoshis,
                    transactionVersion: tx.version,
                    otherInputs,
                    inputIndex,
                    outputs: tx.outputs,
                    inputSequence: input.sequence || 0xffffffff,
                    subscript: lockingScript,
                    lockTime: tx.lockTime,
                    scope: signatureScope,
                });
                const rawSignature = userPrivateKey.sign(sdk_1.Hash.sha256(preimage));
                const sig = new sdk_1.TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);
                const unlockScript = new sdk_1.UnlockingScript();
                unlockScript.writeBin(sig.toChecksigFormat());
                unlockScript.writeBin(userPrivateKey.toPublicKey().encode(true));
                return unlockScript;
            }),
            estimateLength: () => __awaiter(this, void 0, void 0, function* () {
                // public key (1+33) + signature (1+73) + approver signature (1+73)
                // Note: We add 1 to each element's length because of the associated OP_PUSH
                return 182;
            }),
        };
    }
    /**
     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.
     *
     * The returned object contains:
     * 1. `sign` - A function that, when invoked with a transaction and an input index,
     *    produces an unlocking script suitable for a P2PKH locked output.
     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
     *
     * @param {PrivateKey} approverPrivateKey - The private key used for signing the transaction.
     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.
     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.
     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
     */
    unlock(approverPrivateKey, userSigScript, signOutputs = "all", anyoneCanPay = false, sourceSatoshis, lockingScript) {
        return {
            sign: (tx, inputIndex) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                let signatureScope = sdk_1.TransactionSignature.SIGHASH_FORKID;
                if (signOutputs === "all") {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_ALL;
                }
                if (signOutputs === "none") {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_NONE;
                }
                if (signOutputs === "single") {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_SINGLE;
                }
                if (anyoneCanPay) {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_ANYONECANPAY;
                }
                const input = tx.inputs[inputIndex];
                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);
                const sourceTXID = input.sourceTXID
                    ? input.sourceTXID
                    : (_a = input.sourceTransaction) === null || _a === void 0 ? void 0 : _a.id("hex");
                if (!sourceTXID) {
                    throw new Error("The input sourceTXID or sourceTransaction is required for transaction signing.");
                }
                sourceSatoshis || (sourceSatoshis = (_b = input.sourceTransaction) === null || _b === void 0 ? void 0 : _b.outputs[input.sourceOutputIndex].satoshis);
                if (!sourceSatoshis) {
                    throw new Error("The sourceSatoshis or input sourceTransaction is required for transaction signing.");
                }
                lockingScript || (lockingScript = (_c = input.sourceTransaction) === null || _c === void 0 ? void 0 : _c.outputs[input.sourceOutputIndex].lockingScript);
                if (!lockingScript) {
                    throw new Error("The lockingScript or input sourceTransaction is required for transaction signing.");
                }
                const preimage = sdk_1.TransactionSignature.format({
                    sourceTXID,
                    sourceOutputIndex: input.sourceOutputIndex,
                    sourceSatoshis,
                    transactionVersion: tx.version,
                    otherInputs,
                    inputIndex,
                    outputs: tx.outputs,
                    inputSequence: input.sequence || 0xffffffff,
                    subscript: lockingScript,
                    lockTime: tx.lockTime,
                    scope: signatureScope,
                });
                const rawSignature = approverPrivateKey.sign(sdk_1.Hash.sha256(preimage));
                const sig = new sdk_1.TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);
                const unlockScript = new sdk_1.UnlockingScript();
                unlockScript.writeBin(sig.toChecksigFormat());
                unlockScript.writeScript(userSigScript);
                return unlockScript;
            }),
            estimateLength: () => __awaiter(this, void 0, void 0, function* () {
                // public key (1+33) + signature (1+73) + approver signature (1+73)
                // Note: We add 1 to each element's length because of the associated OP_PUSH
                return 182;
            }),
        };
    }
}
exports.default = CosignTemplate;
