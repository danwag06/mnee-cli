"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MNEEService = void 0;
const sdk_1 = require("@bsv/sdk");
const mneeCosignTemplate_js_1 = __importDefault(require("./mneeCosignTemplate.js"));
const js_1sat_ord_1 = __importDefault(require("js-1sat-ord"));
class MNEEService {
    constructor(apiToken) {
        this.mneeApiToken = "92982ec1c0975f31979da515d46bae9f";
        this.mneeApi = "https://proxy-api.mnee.net";
        this.gorillaPoolApi = "https://ordinals.1sat.app";
        if (apiToken)
            this.mneeApiToken = apiToken;
    }
    getConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch(`${this.mneeApi}/v1/config?auth_token=${this.mneeApiToken}`, { method: "GET" });
                if (!response.ok)
                    throw new Error(`HTTP error! status: ${response.status}`);
                const data = yield response.json();
                return data;
            }
            catch (error) {
                console.error("Failed to fetch config:", error);
                return undefined;
            }
        });
    }
    toAtomicAmount(amount, decimals) {
        return Math.round(amount * Math.pow(10, decimals));
    }
    createInscription(recipient, amount, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const inscriptionData = {
                p: "bsv-20",
                op: "transfer",
                id: config.tokenId,
                amt: amount.toString(),
            };
            return {
                lockingScript: js_1sat_ord_1.default.applyInscription(new mneeCosignTemplate_js_1.default().lock(recipient, sdk_1.PublicKey.fromString(config.approver)), {
                    dataB64: Buffer.from(JSON.stringify(inscriptionData)).toString("base64"),
                    contentType: "application/bsv-20",
                }),
                satoshis: 1,
            };
        });
    }
    getUtxos(address_1) {
        return __awaiter(this, arguments, void 0, function* (address, ops = ["transfer", "deploy+mint"]) {
            try {
                const response = yield fetch(`${this.mneeApi}/v1/utxos?auth_token=${this.mneeApiToken}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify([address]),
                });
                if (!response.ok)
                    throw new Error(`HTTP error! status: ${response.status}`);
                const data = yield response.json();
                if (ops.length) {
                    return data.filter((utxo) => ops.includes(utxo.data.bsv21.op.toLowerCase()));
                }
                return data;
            }
            catch (error) {
                console.error("Failed to fetch UTXOs:", error);
                return [];
            }
        });
    }
    broadcast(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.gorillaPoolApi}/v5/tx`;
            try {
                const response = yield fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/octet-stream" },
                    body: Buffer.from(tx.toBinary()),
                });
                const body = yield response.json();
                if (!response.ok) {
                    return {
                        status: "error",
                        code: response.status.toString(),
                        description: body.error || "Unknown error",
                    };
                }
                return {
                    status: "success",
                    txid: body.txid,
                    message: "Transaction broadcast successfully",
                };
            }
            catch (error) {
                console.error("Failed to broadcast:", error);
                return {
                    status: "error",
                    code: "UNKNOWN",
                    description: error instanceof Error ? error.message : "Unknown error",
                };
            }
        });
    }
    fetchBeef(txid) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield fetch(`${this.gorillaPoolApi}/v5/tx/${txid}/beef`);
            if (resp.status === 404)
                throw new Error("Transaction not found");
            if (resp.status !== 200) {
                throw new Error(`${resp.status} - Failed to fetch beef for tx ${txid}`);
            }
            const beef = [...Buffer.from(yield resp.arrayBuffer())];
            return sdk_1.Transaction.fromAtomicBEEF(beef);
        });
    }
    getSignatures(request, privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const DEFAULT_SIGHASH_TYPE = 65;
                let tx;
                switch (request.format) {
                    case "beef":
                        tx = sdk_1.Transaction.fromHexBEEF(request.rawtx);
                        break;
                    case "ef":
                        tx = sdk_1.Transaction.fromHexEF(request.rawtx);
                        break;
                    default:
                        tx = sdk_1.Transaction.fromHex(request.rawtx);
                        break;
                }
                const sigResponses = request.sigRequests.flatMap((sigReq) => {
                    return [privateKey].map((privKey) => {
                        const preimage = sdk_1.TransactionSignature.format({
                            sourceTXID: sigReq.prevTxid,
                            sourceOutputIndex: sigReq.outputIndex,
                            sourceSatoshis: sigReq.satoshis,
                            transactionVersion: tx.version,
                            otherInputs: tx.inputs.filter((_, index) => index !== sigReq.inputIndex),
                            inputIndex: sigReq.inputIndex,
                            outputs: tx.outputs,
                            inputSequence: tx.inputs[sigReq.inputIndex].sequence || 0,
                            subscript: sigReq.script
                                ? sdk_1.Script.fromHex(sigReq.script)
                                : new sdk_1.P2PKH().lock(privKey.toPublicKey().toAddress()),
                            lockTime: tx.lockTime,
                            scope: sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,
                        });
                        const rawSignature = privKey.sign(sdk_1.Hash.sha256(preimage));
                        const sig = new sdk_1.TransactionSignature(rawSignature.r, rawSignature.s, sigReq.sigHashType || DEFAULT_SIGHASH_TYPE);
                        return {
                            sig: sdk_1.Utils.toHex(sig.toChecksigFormat()),
                            pubKey: privKey.toPublicKey().toString(),
                            inputIndex: sigReq.inputIndex,
                            sigHashType: sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,
                            csIdx: sigReq.csIdx,
                        };
                    });
                });
                return Promise.resolve({ sigResponses });
            }
            catch (err) {
                console.error("getSignatures error", err);
                return {
                    error: {
                        message: (_a = err.message) !== null && _a !== void 0 ? _a : "unknown",
                        cause: err.cause,
                    },
                };
            }
        });
    }
    transfer(request, wif) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const config = yield this.getConfig();
                if (!config)
                    throw new Error("Config not fetched");
                const totalAmount = request.reduce((sum, req) => sum + req.amount, 0);
                if (totalAmount <= 0)
                    return { error: "Invalid amount" };
                const totalAtomicTokenAmount = this.toAtomicAmount(totalAmount, config.decimals);
                const privateKey = sdk_1.PrivateKey.fromWif(wif);
                const address = privateKey.toAddress();
                const utxos = yield this.getUtxos(address);
                const totalUtxoAmount = utxos.reduce((sum, utxo) => sum + (utxo.data.bsv21.amt || 0), 0);
                if (totalUtxoAmount < totalAtomicTokenAmount) {
                    return { error: "Insufficient MNEE balance" };
                }
                const fee = request.find((req) => req.address === config.burnAddress) !== undefined
                    ? 0
                    : (_a = config.fees.find((fee) => totalAtomicTokenAmount >= fee.min &&
                        totalAtomicTokenAmount <= fee.max)) === null || _a === void 0 ? void 0 : _a.fee;
                if (fee === undefined)
                    return { error: "Fee ranges inadequate" };
                const tx = new sdk_1.Transaction(1, [], [], 0);
                let tokensIn = 0;
                const signingAddresses = [];
                let changeAddress = "";
                while (tokensIn < totalAtomicTokenAmount + fee) {
                    const utxo = utxos.shift();
                    if (!utxo)
                        return { error: "Insufficient MNEE balance" };
                    const sourceTransaction = yield this.fetchBeef(utxo.txid);
                    if (!sourceTransaction)
                        return { error: "Failed to fetch source transaction" };
                    signingAddresses.push(utxo.owners[0]);
                    changeAddress = changeAddress || utxo.owners[0];
                    tx.addInput({
                        sourceTXID: utxo.txid,
                        sourceOutputIndex: utxo.vout,
                        sourceTransaction,
                        unlockingScript: new sdk_1.UnlockingScript(),
                    });
                    tokensIn += utxo.data.bsv21.amt;
                }
                for (const req of request) {
                    tx.addOutput(yield this.createInscription(req.address, this.toAtomicAmount(req.amount, config.decimals), config));
                }
                if (fee > 0)
                    tx.addOutput(yield this.createInscription(config.feeAddress, fee, config));
                const change = tokensIn - totalAtomicTokenAmount - fee;
                if (change > 0) {
                    tx.addOutput(yield this.createInscription(changeAddress, change, config));
                }
                const sigRequests = tx.inputs.map((input, index) => {
                    var _a, _b;
                    if (!input.sourceTXID)
                        throw new Error("Source TXID is undefined");
                    return {
                        prevTxid: input.sourceTXID,
                        outputIndex: input.sourceOutputIndex,
                        inputIndex: index,
                        address: signingAddresses[index],
                        script: (_a = input.sourceTransaction) === null || _a === void 0 ? void 0 : _a.outputs[input.sourceOutputIndex].lockingScript.toHex(),
                        satoshis: ((_b = input.sourceTransaction) === null || _b === void 0 ? void 0 : _b.outputs[input.sourceOutputIndex].satoshis) || 1,
                        sigHashType: sdk_1.TransactionSignature.SIGHASH_ALL |
                            sdk_1.TransactionSignature.SIGHASH_ANYONECANPAY |
                            sdk_1.TransactionSignature.SIGHASH_FORKID,
                    };
                });
                const rawtx = tx.toHex();
                const res = yield this.getSignatures({ rawtx, sigRequests }, privateKey);
                if (!(res === null || res === void 0 ? void 0 : res.sigResponses))
                    return { error: "Failed to get signatures" };
                for (const sigResponse of res.sigResponses) {
                    tx.inputs[sigResponse.inputIndex].unlockingScript = new sdk_1.Script()
                        .writeBin(sdk_1.Utils.toArray(sigResponse.sig, "hex"))
                        .writeBin(sdk_1.Utils.toArray(sigResponse.pubKey, "hex"));
                }
                const base64Tx = sdk_1.Utils.toBase64(tx.toBinary());
                const response = yield fetch(`${this.mneeApi}/v1/transfer?auth_token=${this.mneeApiToken}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ rawtx: base64Tx }),
                });
                if (!response.ok)
                    throw new Error(`HTTP error! status: ${response.status}`);
                const { rawtx: responseRawtx } = yield response.json();
                if (!responseRawtx)
                    return { error: "Failed to broadcast transaction" };
                const decodedBase64AsBinary = sdk_1.Utils.toArray(responseRawtx, "base64");
                const tx2 = sdk_1.Transaction.fromBinary(decodedBase64AsBinary);
                yield this.broadcast(tx2);
                return { txid: tx2.id("hex"), rawtx: sdk_1.Utils.toHex(decodedBase64AsBinary) };
            }
            catch (error) {
                let errorMessage = "Transaction submission failed";
                if (error instanceof Error) {
                    errorMessage = error.message;
                    if (error.message.includes("HTTP error")) {
                        // Add more specific error handling if needed based on response status
                        console.error("HTTP error details:", error);
                    }
                }
                console.error("Failed to transfer tokens:", errorMessage);
                return { error: errorMessage };
            }
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const config = yield this.getConfig();
                if (!config)
                    throw new Error("Config not fetched");
                const res = yield this.getUtxos(address);
                const balance = res.reduce((acc, utxo) => {
                    if (utxo.data.bsv21.op === "transfer") {
                        acc += utxo.data.bsv21.amt;
                    }
                    return acc;
                }, 0);
                const decimalAmount = parseFloat((balance / Math.pow(10, (config.decimals || 0))).toFixed(config.decimals));
                return { amount: balance, decimalAmount };
            }
            catch (error) {
                console.error("Failed to fetch balance:", error);
                return { amount: 0, decimalAmount: 0 };
            }
        });
    }
}
exports.MNEEService = MNEEService;
